{"id":"remote_compilation_helper-17q","title":"Fix broken 'rch config set' command","description":"commands.rs:726-730 prints 'not fully implemented' instead of actually setting config values. Either implement the feature properly or remove the command from the CLI until ready.","status":"closed","priority":2,"issue_type":"bug","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:06.154251039-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:53:10.653219201-05:00","closed_at":"2026-01-16T11:53:10.653223119-05:00"}
{"id":"remote_compilation_helper-1f5","title":"Add shell completion generation (bash/zsh/fish)","description":"## Overview\nGenerate shell completions for bash, zsh, and fish to enable tab-completion for all commands, subcommands, and options.\n\n## Dependencies\n- None (can be implemented independently)\n\n## Requirements\n\n### Completion Command\nAdd new subcommand:\n```\nrch completion \u003cSHELL\u003e\n\nGenerate shell completions for the specified shell.\n\nARGUMENTS:\n    \u003cSHELL\u003e    Target shell [bash, zsh, fish, powershell, elvish]\n\nEXAMPLES:\n    # Bash (add to ~/.bashrc)\n    source \u003c(rch completion bash)\n    \n    # Zsh (add to ~/.zshrc)\n    source \u003c(rch completion zsh)\n    \n    # Fish (save to completions directory)\n    rch completion fish \u003e ~/.config/fish/completions/rch.fish\n```\n\n### Implementation\nUse `clap_complete` crate:\n```rust\nuse clap_complete::{generate, shells::*};\n\nfn print_completions\u003cG: Generator\u003e(gen: G, cmd: \u0026mut Command) {\n    generate(gen, cmd, \"rch\", \u0026mut std::io::stdout());\n}\n```\n\n### Completion Features\n1. **Command completion**: `rch da\u003cTAB\u003e` â†’ `rch daemon`\n2. **Subcommand completion**: `rch daemon st\u003cTAB\u003e` â†’ `rch daemon start` / `rch daemon status`\n3. **Flag completion**: `rch --\u003cTAB\u003e` â†’ shows all global flags\n4. **Worker ID completion** (advanced): `rch workers probe \u003cTAB\u003e` â†’ lists worker IDs\n   - This requires dynamic completion, may be shell-specific\n   - Consider generating static completion for common cases\n\n### Installation Instructions\nInclude in help text and README:\n\n**Bash:**\n```bash\n# Add to ~/.bashrc or ~/.bash_profile\neval \"$(rch completion bash)\"\n\n# Or save to file\nrch completion bash \u003e /etc/bash_completion.d/rch\n```\n\n**Zsh:**\n```bash\n# Add to ~/.zshrc\neval \"$(rch completion zsh)\"\n\n# Or save to fpath\nrch completion zsh \u003e ~/.zfunc/_rch\n# Ensure ~/.zfunc is in fpath before compinit\n```\n\n**Fish:**\n```bash\nrch completion fish \u003e ~/.config/fish/completions/rch.fish\n```\n\n### Files to Modify\n- `rch/src/main.rs` - add Completion command\n- `Cargo.toml` (rch) - add clap_complete dependency\n- `README.md` - document completion installation\n\n## Testing Requirements\n\n### Unit Tests\n- Test completion generation doesn't panic for each shell\n- Test output is non-empty\n\n### Integration Tests\n```rust\n#[test]\nfn test_bash_completion_generates() {\n    let output = Command::new(\"rch\")\n        .args([\"completion\", \"bash\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"_rch\"));  // bash completion function\n}\n\n#[test]\nfn test_zsh_completion_generates() {\n    let output = Command::new(\"rch\")\n        .args([\"completion\", \"zsh\"])\n        .output()\n        .expect(\"failed to run\");\n    assert!(output.status.success());\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"#compdef rch\"));\n}\n```\n\n### E2E Test Additions\n```bash\n# Verify completions generate without error\ntest_completions() {\n    for shell in bash zsh fish; do\n        if ! rch completion \"$shell\" \u003e /dev/null 2\u003e\u00261; then\n            log \"FAIL\" \"COMPLETION\" \"Failed to generate $shell completions\"\n            return 1\n        fi\n        log \"INFO\" \"COMPLETION\" \"$shell completions OK\"\n    done\n}\n```\n\n### Manual Testing\n- Install completions in each shell\n- Verify tab completion works for commands\n- Verify tab completion works for flags\n\n## Acceptance Criteria\n- [ ] `rch completion` command exists\n- [ ] Generates valid completions for bash, zsh, fish\n- [ ] Installation instructions in help and README\n- [ ] Completions include all commands and flags\n- [ ] Unit tests verify generation\n- [ ] Manual testing confirms completion works","status":"open","priority":3,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:04.972457231-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:00:13.623410382-05:00"}
{"id":"remote_compilation_helper-2ug","title":"Integrate hook with remote transfer pipeline","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:58:30.199568598-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:03:44.627509668-05:00","closed_at":"2026-01-16T09:03:44.627509668-05:00","close_reason":"Integrated hook with remote transfer pipeline"}
{"id":"remote_compilation_helper-3d1","title":"Epic: First-Run Setup Wizard with Validation","description":"## Overview\n\nImplement an interactive setup experience that guides new users through RCH configuration: discovering/adding workers, testing SSH connectivity, validating the setup, and installing the Claude Code hook. The wizard ensures users have a working setup before they try to use RCH.\n\n## Problem Statement\n\nCurrent setup experience:\n1. User must manually create ~/.config/rch/workers.toml\n2. User must know the correct TOML format\n3. No validation until first build attempt fails\n4. Hook installation is a separate manual step\n5. Users often have typos, wrong paths, or connectivity issues\n\nResult: High friction onboarding, frustrated users, support burden.\n\n## Goals\n\n1. Single command to go from \"installed\" to \"working\"\n2. Interactive prompts guide user through configuration\n3. Validate everything before declaring success\n4. Auto-detect worker capabilities where possible\n5. Install Claude Code hook automatically\n6. Test end-to-end with a real (or simulated) build\n\n## Design\n\n### CLI Interface\n```bash\nrch setup                     # Full interactive wizard\nrch setup --quick             # Minimal prompts, sensible defaults\nrch setup --worker \u003chost\u003e     # Add single worker non-interactively\nrch setup --validate          # Validate existing config only\n```\n\n### Wizard Flow\n```\n$ rch setup\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚         Welcome to Remote Compilation Helper! ğŸš€        â”‚\nâ”‚                                                         â”‚\nâ”‚  This wizard will help you set up RCH in a few steps.  â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nStep 1 of 5: Worker Configuration\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nRCH needs at least one remote worker to compile your code.\n\n? Add a worker now? (Y/n) y\n\n? Worker hostname or IP: 192.168.1.100\n? SSH username (ubuntu): \n? SSH key path (~/.ssh/id_rsa): \n? Worker nickname (auto: worker-1): fast-builder\n\n  Testing SSH connection...\n  âœ“ Connected successfully\n  \n  Detecting capabilities...\n  âœ“ CPU cores: 16\n  âœ“ Rust toolchain: rustc 1.76.0-nightly\n  âœ“ rsync: 3.2.7\n  âœ“ zstd: 1.5.5\n\n? Add another worker? (y/N) n\n\nStep 2 of 5: Configuration Files\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Creating ~/.config/rch/config.toml... âœ“\n  Creating ~/.config/rch/workers.toml... âœ“\n\nStep 3 of 5: Daemon Setup\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n? Start daemon automatically on login? (Y/n) y\n  Installing launchd service... âœ“\n  Starting daemon... âœ“\n  \n  Verifying daemon...\n  âœ“ Daemon running (pid 12345)\n  âœ“ Socket created at /tmp/rch.sock\n\nStep 4 of 5: Claude Code Hook\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Detecting Claude Code installation...\n  âœ“ Found Claude Code at ~/.claude\n\n? Install RCH hook for Claude Code? (Y/n) y\n  Installing hook... âœ“\n  âœ“ Hook installed at ~/.claude/hooks/pre_tool_use.rch\n\nStep 5 of 5: Verification\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Running end-to-end test...\n  \n  â†’ Creating test project\n  â†’ Triggering remote build on fast-builder\n  â†’ Verifying artifact retrieval\n  \n  âœ“ Test build completed in 2.3s\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚                    Setup Complete! âœ“                    â”‚\nâ”‚                                                         â”‚\nâ”‚  RCH is now configured with 1 worker.                  â”‚\nâ”‚                                                         â”‚\nâ”‚  Next steps:                                            â”‚\nâ”‚  â€¢ Run 'rch status' to check system health             â”‚\nâ”‚  â€¢ Start using Claude Code - builds will be offloaded  â”‚\nâ”‚  â€¢ Run 'rch setup --worker \u003chost\u003e' to add more workers â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n```\n\n### Implementation Components\n\n1. **Interactive Prompts**: Use `dialoguer` or `inquire` crate\n2. **SSH Testing**: `SshClient::new(config).connect().await`\n3. **Capability Detection**: Run commands on worker to detect versions\n4. **Config Generation**: Template-based TOML generation\n5. **Daemon Management**: Start/stop daemon, verify socket\n6. **Hook Installation**: Copy hook script, set permissions\n7. **E2E Verification**: Create temp project, trigger build, verify\n\n### Capability Detection Commands\n```rust\nstruct WorkerCapabilities {\n    cpu_cores: u32,        // nproc\n    memory_gb: u32,        // free -g\n    rustc_version: String, // rustc --version\n    cargo_version: String, // cargo --version\n    rsync_version: String, // rsync --version\n    zstd_available: bool,  // which zstd\n    disk_free_gb: u32,     // df -BG /tmp\n}\n\nasync fn detect_capabilities(client: \u0026SshClient) -\u003e Result\u003cWorkerCapabilities\u003e {\n    // Run detection commands in parallel for speed\n}\n```\n\n### Validation Checks\n- SSH connectivity with provided credentials\n- Passwordless SSH (BatchMode) works\n- Required tools available (rustc, cargo, rsync)\n- Sufficient disk space on worker\n- Network latency acceptable\n- No conflicting RCH installations\n\n## Rationale\n\nThis is ranked #5 of 5 improvements because:\n- Dramatically reduces onboarding friction\n- First impressions matter - polished setup builds confidence\n- Validates configuration upfront (catches issues early)\n- Reduces support burden (users don't get stuck)\n- Teaches users about the system (workers, health, etc.)\n- Can incorporate validation for features from other epics\n\n## Edge Cases\n\n1. **User cancels mid-setup**: Partial config should be cleaned up or noted\n2. **Worker unreachable**: Clear error, option to skip/retry\n3. **Missing tools on worker**: Suggest installation commands\n4. **Permission denied**: Check SSH key permissions, suggest fixes\n5. **Existing config**: Offer to merge or replace\n6. **No Claude Code**: Skip hook installation gracefully\n\n## Success Criteria\n\n- [ ] `rch setup` completes full wizard flow\n- [ ] Worker SSH connectivity validated before saving\n- [ ] Worker capabilities auto-detected\n- [ ] Config files created with correct format\n- [ ] Daemon started and verified\n- [ ] Hook installed for Claude Code\n- [ ] E2E verification test passes\n- [ ] Clear error messages for all failure modes\n- [ ] Existing config handled gracefully\n- [ ] All existing tests pass\n\n## Estimated Effort: 3-4 days\n\n## Dependencies\n- Local Fallback epic (wizard can test fallback behavior)\n- Toolchain Sync epic (wizard can verify toolchain compatibility)\n- rch status epic (wizard references status command)","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:07:37.661350839-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:07:37.661350839-05:00"}
{"id":"remote_compilation_helper-3n1","title":"Implement artifact return from workers","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:20:09.410470904-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:30:55.108000517-05:00","closed_at":"2026-01-16T03:30:55.108000517-05:00","close_reason":"Artifact return already implemented in rch/src/transfer.rs::retrieve_artifacts() - uses rsync with zstd compression to pull back target/debug/**, target/release/**, etc. Tested via parse_rsync_bytes test."}
{"id":"remote_compilation_helper-3nq","title":"Enhance help text with examples and env var documentation","description":"## Overview\nEnhance CLI help text to be comprehensive, educational, and example-rich. Users should be able to learn the tool entirely from --help output.\n\n## Dependencies\n- None (can be implemented independently)\n\n## Requirements\n\n### Main Help (`rch --help`)\n```\nRemote Compilation Helper - transparent compilation offloading\n\nRCH intercepts compilation commands and executes them on remote workers,\nseamlessly returning results. When running without arguments, RCH operates\nas a Claude Code PreToolUse hook.\n\nUSAGE:\n    rch [OPTIONS] [COMMAND]\n\nCOMMANDS:\n    daemon   Manage the background daemon (start, stop, status)\n    workers  Manage remote worker fleet (list, probe, benchmark)\n    config   Configuration management (show, init, validate)\n    hook     Claude Code hook management (install, uninstall, test)\n    status   Show overall system status\n\nOPTIONS:\n    -v, --verbose      Enable verbose output (show debug information)\n    -q, --quiet        Suppress non-error output\n        --json         Output in JSON format (for scripting)\n        --color \u003cWHEN\u003e Control color output [auto, always, never]\n    -h, --help         Print help\n    -V, --version      Print version\n\nENVIRONMENT VARIABLES:\n    RCH_SOCKET_PATH    Override daemon socket path [default: /tmp/rch.sock]\n    RCH_LOG_LEVEL      Set log level [trace, debug, info, warn, error]\n    RCH_CONFIG_DIR     Override config directory [default: ~/.config/rch]\n    NO_COLOR           Disable colored output (standard: https://no-color.org)\n\nEXAMPLES:\n    # Quick start\n    rch config init          # Create initial configuration\n    rch daemon start         # Start the daemon\n    rch status               # Check everything is working\n\n    # As Claude Code hook (automatic via hook install)\n    echo '{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"cargo build\"}}' | rch\n\nLEARN MORE:\n    https://github.com/your/repo#readme\n```\n\n### Command-Specific Help Examples\n\n#### `rch daemon --help`\nInclude after_help with examples:\n```\nEXAMPLES:\n    rch daemon start         # Start daemon in background\n    rch daemon start -f      # Start in foreground (for debugging)\n    rch daemon status        # Check if daemon is running\n    rch daemon logs          # View recent daemon logs\n    rch daemon restart       # Stop and start daemon\n```\n\n#### `rch workers --help`\n```\nEXAMPLES:\n    rch workers list                    # List all configured workers\n    rch workers probe gpu-worker        # Test connectivity to one worker\n    rch workers probe --all             # Test all workers\n    rch workers benchmark --all         # Run speed benchmarks\n    rch workers drain gpu-worker        # Stop sending new jobs to worker\n```\n\n#### `rch config --help`\n```\nEXAMPLES:\n    rch config init          # Create example config files\n    rch config show          # Display effective configuration\n    rch config validate      # Check config for errors\n    rch config show --json   # Output config as JSON\n```\n\n### Environment Variable Documentation\nFor each env var, document in relevant command help:\n- `RCH_SOCKET_PATH` - in daemon commands\n- `RCH_LOG_LEVEL` - in daemon start\n- `NO_COLOR` - in root help\n- `RCH_MOCK_SSH` - in development/testing section\n\n### Hook Mode Documentation\nAdd clear explanation that running `rch` without arguments is hook mode:\n- What input format it expects\n- What output it produces\n- How it interacts with the daemon\n\n### Files to Modify\n- `rch/src/main.rs` - add after_help to Cli struct\n- Add after_help to each subcommand's Args struct\n- Consider adding `rch help \u003ctopic\u003e` for extended documentation\n\n## Testing Requirements\n\n### Unit Tests\n- Test that help text contains expected sections\n- Test that examples are present\n- Verify env vars are documented\n\n### Integration Tests\n```rust\n#[test]\nfn test_help_contains_examples() {\n    let output = Command::new(\"rch\")\n        .arg(\"--help\")\n        .output()\n        .expect(\"failed to run\");\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"EXAMPLES:\"));\n    assert!(stdout.contains(\"rch config init\"));\n}\n\n#[test]\nfn test_help_documents_env_vars() {\n    let output = Command::new(\"rch\")\n        .arg(\"--help\")\n        .output()\n        .expect(\"failed to run\");\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    assert!(stdout.contains(\"RCH_SOCKET_PATH\"));\n    assert!(stdout.contains(\"NO_COLOR\"));\n}\n```\n\n### E2E Test Additions\n```bash\n# Verify help text is comprehensive\nverify_help_quality() {\n    local help_output\n    help_output=$(rch --help)\n    \n    # Check for required sections\n    echo \"$help_output\" | grep -q \"EXAMPLES:\" || die \"Missing EXAMPLES section\"\n    echo \"$help_output\" | grep -q \"ENVIRONMENT\" || die \"Missing ENVIRONMENT section\"\n    \n    log \"INFO\" \"HELP\" \"Help text quality verified\"\n}\n```\n\n## Acceptance Criteria\n- [ ] Main help includes examples section\n- [ ] All subcommands have examples\n- [ ] Environment variables documented\n- [ ] Hook mode behavior explained\n- [ ] Help tests pass\n- [ ] Help text fits standard terminal width (80 chars)","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:07.353322307-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:59:37.122548034-05:00"}
{"id":"remote_compilation_helper-4ck","title":"Create Cargo workspace scaffold","description":"Set up Cargo.toml workspace with 4 crates: rch, rchd, rch-wkr, rch-common. Include rust-toolchain.toml for nightly 2024. Configure release profile per AGENTS.md.","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:09:00.450176064-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:19:14.337156716-05:00","closed_at":"2026-01-16T03:19:14.337156716-05:00","close_reason":"Created complete Cargo workspace with rch, rchd, rch-wkr, rch-common crates. All tests pass."}
{"id":"remote_compilation_helper-4ur","title":"Add reason field to SelectionResponse for no-worker cases","description":"## Parent Epic: Graceful Local Fallback (remote_compilation_helper-ne8)\n\n## Task Description\n\nExtend the SelectionResponse protocol to include a reason field that explains why no worker was assigned. This enables the hook to provide informative messaging when falling back to local execution.\n\n## Current State\n\n```rust\n// In rch-common/src/protocol.rs (or similar)\npub struct SelectionResponse {\n    pub worker: Option\u003cWorkerConfig\u003e,\n    pub slots_reserved: u32,\n    // ...\n}\n```\n\nWhen no worker is available, `worker` is `None` but there's no indication of WHY.\n\n## Changes Required\n\n### 1. Update SelectionResponse\n```rust\npub struct SelectionResponse {\n    pub worker: Option\u003cWorkerConfig\u003e,\n    pub slots_reserved: u32,\n    pub reason: Option\u003cSelectionReason\u003e,  // NEW\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum SelectionReason {\n    /// Worker assigned successfully\n    Success,\n    /// No workers configured in workers.toml\n    NoWorkersConfigured,\n    /// All workers are unreachable\n    AllWorkersUnreachable,\n    /// All workers have circuits open (after circuit breaker epic)\n    AllCircuitsOpen,\n    /// All workers are at capacity (no available slots)\n    AllWorkersBusy,\n    /// No workers match required tags/preferences\n    NoMatchingWorkers,\n    /// Internal error during selection\n    SelectionError(String),\n}\n```\n\n### 2. Update selection.rs\n```rust\npub async fn select_worker(...) -\u003e SelectionResponse {\n    if workers.is_empty() {\n        return SelectionResponse {\n            worker: None,\n            slots_reserved: 0,\n            reason: Some(SelectionReason::NoWorkersConfigured),\n        };\n    }\n    \n    let healthy = workers.iter().filter(|w| w.is_healthy()).collect::\u003cVec\u003c_\u003e\u003e();\n    if healthy.is_empty() {\n        return SelectionResponse {\n            worker: None,\n            slots_reserved: 0,\n            reason: Some(SelectionReason::AllWorkersUnreachable),\n        };\n    }\n    \n    // ... selection logic ...\n    \n    if selected.is_none() {\n        return SelectionResponse {\n            worker: None,\n            slots_reserved: 0,\n            reason: Some(SelectionReason::AllWorkersBusy),\n        };\n    }\n    \n    SelectionResponse {\n        worker: selected,\n        slots_reserved: cores,\n        reason: Some(SelectionReason::Success),\n    }\n}\n```\n\n### 3. Update API serialization\nEnsure the new field is properly serialized in the HTTP response from daemon.\n\n## Files to Modify\n- `rch-common/src/protocol.rs` or `rch-common/src/types.rs`\n- `rchd/src/selection.rs`\n- `rchd/src/api.rs`\n\n## Testing\n\nAdd tests for each SelectionReason case:\n```rust\n#[test]\nfn test_selection_response_no_workers() {\n    // Empty pool returns NoWorkersConfigured\n}\n\n#[test]\nfn test_selection_response_all_unreachable() {\n    // All workers Unreachable returns AllWorkersUnreachable\n}\n\n#[test]\nfn test_selection_response_all_busy() {\n    // All slots used returns AllWorkersBusy\n}\n```\n\n## Acceptance Criteria\n- [ ] SelectionReason enum defined with all cases\n- [ ] SelectionResponse includes reason field\n- [ ] selection.rs populates reason correctly for each case\n- [ ] API serializes reason in JSON response\n- [ ] Unit tests cover all reason variants\n- [ ] Existing tests updated/pass\n\n## Estimated Effort: 2-3 hours","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:07:57.468294764-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:07:57.468294764-05:00"}
{"id":"remote_compilation_helper-52l","title":"Integrate circuit state into WorkerHealth and health check loop","description":"## Parent Epic: Circuit Breaker Pattern (remote_compilation_helper-9pw)\n\n## Task Description\n\nIntegrate the CircuitState into the existing WorkerHealth struct and modify the health check loop to respect circuit states. This is the core implementation of the circuit breaker pattern.\n\n## Current State\n\nIn `rchd/src/health.rs`:\n```rust\npub struct WorkerHealth {\n    consecutive_failures: u32,\n    last_result: Option\u003cHealthCheckResult\u003e,\n    current_status: WorkerStatus,\n}\n```\n\nThe health monitor runs checks at a fixed interval for all workers.\n\n## Changes Required\n\n### 1. Extend WorkerHealth\n```rust\npub struct WorkerHealth {\n    consecutive_failures: u32,\n    last_result: Option\u003cHealthCheckResult\u003e,\n    current_status: WorkerStatus,\n    circuit: CircuitState,  // NEW\n    circuit_config: CircuitBreakerConfig,  // NEW (or reference shared config)\n}\n\nimpl WorkerHealth {\n    /// Update health state and circuit based on check result\n    pub fn update(\u0026mut self, result: HealthCheckResult) {\n        if result.healthy {\n            self.handle_success(result);\n        } else {\n            self.handle_failure(result);\n        }\n    }\n    \n    fn handle_success(\u0026mut self, result: HealthCheckResult) {\n        self.consecutive_failures = 0;\n        self.last_result = Some(result);\n        \n        match \u0026self.circuit {\n            CircuitState::HalfOpen { .. } =\u003e {\n                // Probe succeeded - close the circuit\n                tracing::info!(\"Circuit closing after successful probe\");\n                self.circuit = CircuitState::Closed;\n                self.current_status = WorkerStatus::Healthy;\n            }\n            CircuitState::Closed =\u003e {\n                // Normal success - check for degraded\n                if result.response_time_ms \u003e self.circuit_config.degraded_threshold_ms {\n                    self.current_status = WorkerStatus::Degraded;\n                } else {\n                    self.current_status = WorkerStatus::Healthy;\n                }\n            }\n            CircuitState::Open { .. } =\u003e {\n                // Shouldn't happen - we only check when should_probe() is true\n                unreachable!(\"Success while circuit is open\");\n            }\n        }\n    }\n    \n    fn handle_failure(\u0026mut self, result: HealthCheckResult) {\n        self.consecutive_failures += 1;\n        self.last_result = Some(result);\n        \n        match \u0026mut self.circuit {\n            CircuitState::Closed =\u003e {\n                if self.consecutive_failures \u003e= self.circuit_config.failure_threshold {\n                    self.trip_circuit();\n                } else {\n                    self.current_status = WorkerStatus::Degraded;\n                }\n            }\n            CircuitState::HalfOpen { .. } =\u003e {\n                // Probe failed - re-trip with increased backoff\n                self.trip_circuit();\n            }\n            CircuitState::Open { .. } =\u003e {\n                // Shouldn't happen\n                unreachable!(\"Failure while circuit is open\");\n            }\n        }\n    }\n    \n    fn trip_circuit(\u0026mut self) {\n        let trip_count = match \u0026self.circuit {\n            CircuitState::Open { trip_count, .. } =\u003e trip_count + 1,\n            _ =\u003e 1,\n        };\n        \n        let cooldown = self.circuit_config.cooldown_for_trip(trip_count);\n        let next_probe = Instant::now() + cooldown;\n        \n        tracing::warn!(\n            trip_count = trip_count,\n            cooldown_secs = cooldown.as_secs(),\n            \"Circuit tripped\"\n        );\n        \n        self.circuit = CircuitState::Open {\n            tripped_at: Instant::now(),\n            trip_count,\n            next_probe_at: next_probe,\n        };\n        self.current_status = WorkerStatus::Unreachable;\n    }\n    \n    /// Get current circuit state\n    pub fn circuit_state(\u0026self) -\u003e \u0026CircuitState {\n        \u0026self.circuit\n    }\n}\n```\n\n### 2. Modify Health Check Loop\n```rust\n// In HealthMonitor::start()\n\nloop {\n    ticker.tick().await;\n    \n    let workers = pool.all_workers().await;\n    \n    for worker in workers {\n        let worker_id = worker.config.id.clone();\n        let mut states = health_states.write().await;\n        let health = states.entry(worker_id.clone()).or_default();\n        \n        // NEW: Check circuit state before performing health check\n        match \u0026health.circuit {\n            CircuitState::Closed =\u003e {\n                // Normal health check\n                let result = check_worker_health(\u0026worker, \u0026config).await;\n                health.update(result);\n            }\n            CircuitState::Open { next_probe_at, .. } =\u003e {\n                if Instant::now() \u003e= *next_probe_at {\n                    // Time to probe - transition to half-open\n                    tracing::info!(worker = %worker_id, \"Circuit entering half-open state\");\n                    health.circuit = CircuitState::HalfOpen {\n                        entered_at: Instant::now(),\n                    };\n                    // Perform probe\n                    let result = check_worker_health(\u0026worker, \u0026config).await;\n                    health.update(result);\n                } else {\n                    // Skip check - circuit still open\n                    tracing::debug!(\n                        worker = %worker_id,\n                        \"Skipping health check - circuit open\"\n                    );\n                }\n            }\n            CircuitState::HalfOpen { .. } =\u003e {\n                // Perform probe check\n                let result = check_worker_health(\u0026worker, \u0026config).await;\n                health.update(result);\n            }\n        }\n        \n        // Update worker pool status\n        pool.set_status(\u0026worker.config.id, health.current_status).await;\n    }\n}\n```\n\n## Files to Modify\n- `rchd/src/health.rs`\n\n## Testing\n```rust\n#[test]\nfn test_circuit_trips_after_threshold_failures() {\n    let config = CircuitBreakerConfig {\n        failure_threshold: 3,\n        ..Default::default()\n    };\n    let mut health = WorkerHealth::with_config(config);\n    \n    // First two failures: degraded but circuit closed\n    health.update(HealthCheckResult::failure(\"err\".into()));\n    assert!(health.circuit.is_closed());\n    \n    health.update(HealthCheckResult::failure(\"err\".into()));\n    assert!(health.circuit.is_closed());\n    \n    // Third failure: circuit trips\n    health.update(HealthCheckResult::failure(\"err\".into()));\n    assert!(health.circuit.is_open());\n}\n\n#[test]\nfn test_circuit_closes_after_successful_probe() {\n    let mut health = WorkerHealth::default();\n    // Manually set to half-open\n    health.circuit = CircuitState::HalfOpen {\n        entered_at: Instant::now(),\n    };\n    \n    // Successful probe\n    health.update(HealthCheckResult::success(50));\n    assert!(health.circuit.is_closed());\n}\n\n#[test]\nfn test_circuit_retrips_after_failed_probe() {\n    let mut health = WorkerHealth::default();\n    // Set to half-open\n    health.circuit = CircuitState::HalfOpen {\n        entered_at: Instant::now(),\n    };\n    \n    // Failed probe\n    health.update(HealthCheckResult::failure(\"still down\".into()));\n    assert!(health.circuit.is_open());\n    \n    // Trip count should be incremented\n    if let CircuitState::Open { trip_count, .. } = health.circuit {\n        assert!(trip_count \u003e= 1);\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] WorkerHealth includes CircuitState\n- [ ] Health check loop respects circuit states\n- [ ] Closed: normal checks\n- [ ] Open: skip checks until probe time\n- [ ] HalfOpen: probe checks\n- [ ] Circuit trips correctly after failure threshold\n- [ ] Circuit closes after successful probe\n- [ ] Circuit re-trips with increased backoff after failed probe\n- [ ] Logging for state transitions\n- [ ] All tests pass\n\n## Dependencies\n- Requires: \"Define CircuitState enum and CircuitBreakerConfig\" task\n\n## Estimated Effort: 3-4 hours","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:10:32.305110642-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:10:32.305110642-05:00","dependencies":[{"issue_id":"remote_compilation_helper-52l","depends_on_id":"remote_compilation_helper-62v","type":"blocks","created_at":"2026-01-16T12:12:01.869594158-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-5cv","title":"Implement rch hook CLI","description":"Create rch binary with main.rs, hook.rs, classify.rs. Parse Claude Code PreToolUse JSON and classify commands.","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:09:02.849264782-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:19:17.532584191-05:00","closed_at":"2026-01-16T03:19:17.532584191-05:00","close_reason":"Implemented rch hook CLI with main.rs, hook.rs, config.rs. Command classification working."}
{"id":"remote_compilation_helper-5te","title":"Add progress indicators for long operations (spinners, progress bars)","description":"## Overview\nAdd visual feedback for long-running operations using spinners, progress bars, and step indicators. Users should never wonder \"is it still working?\"\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-u0v (UI output abstraction layer)\n- **BLOCKED BY**: remote_compilation_helper-nbo (colors) - progress elements use colors\n\n**Can be worked in PARALLEL with cmj (status indicators) and alo (errors) after nbo completes.**\n\n## Requirements\n\n### Crate Selection\nUse `indicatif` crate (v0.17+) - the Rust standard for progress indication:\n- Spinners with customizable styles\n- Progress bars with ETA, speed, percentage\n- Multi-progress for parallel operations\n- Built-in non-TTY handling\n\n### Progress Types\n\n#### 1. Spinner - Unknown Duration Operations\n```\nâ ‹ Connecting to gpu-worker...\nâ ™ Probing mock-worker...\nâ ¹ Starting daemon...\n```\n- Style: Braille dots `â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â ` (indicatif `Dots` style)\n- Message updates as operation progresses\n- Completes with âœ“ or âœ— and final message\n- Use for: SSH connection, daemon startup, single worker probe\n\n#### 2. Progress Bar - Known Size Operations\n```\nSyncing files   [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 48% 2.3 MB/s ETA 0:12\n```\n- Shows: percentage, transfer speed, ETA\n- Width adapts to terminal\n- Use for: file sync (rsync), artifact retrieval\n\n#### 3. Step Indicator - Multi-Phase Operations\n```\n[1/3] âœ“ Synced files (2.3 MB in 3.2s)\n[2/3] â— Compiling on gpu-worker...\n[3/3] â—‹ Retrieve artifacts\n```\n- Show completed, current, pending steps\n- Current step may have nested progress\n- Use for: hook compilation pipeline\n\n#### 4. Multi-Progress - Parallel Operations\n```\ngpu-worker   âœ“ OK (45ms)\ncpu-worker   â ¹ Connecting...\nbackup       âœ— Connection refused\n```\n- Multiple lines, each with own status\n- Updates in place\n- Use for: `workers probe --all`, `workers benchmark`\n\n### Critical: Progress + Streaming Output Coexistence\n\nDuring `execute_remote`, compilation output streams to the terminal. This conflicts with progress indicators.\n\n**Solution: Output Regions**\n```\n[2/3] â— Compiling on gpu-worker...\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   Compiling rch v0.1.0\n   Compiling rch-common v0.1.0\n     Running `target/debug/test`\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n- Progress indicator above\n- Streaming output in \"region\" below\n- On completion, collapse or keep last N lines\n\n**Implementation:**\n- Use `indicatif::MultiProgress` with suspended drawing during streaming\n- Or use `console` crate's terminal control for regions\n- Document chosen approach in implementation\n\n### rsync Progress Integration\n\nrsync with `--info=progress2` outputs:\n```\n    123,456,789 100%   10.50MB/s    0:00:11 (xfr#42, to-chk=0/100)\n```\n\n**Parsing approach:**\n- Add `--info=progress2` to rsync commands\n- Spawn rsync with stdout piped\n- Parse progress lines and update indicatif bar\n- Forward non-progress output as-is\n\n```rust\n// In transfer.rs\npub struct TransferProgress {\n    pub bytes_transferred: u64,\n    pub total_bytes: Option\u003cu64\u003e,\n    pub speed_bytes_per_sec: u64,\n    pub files_transferred: u32,\n    pub total_files: Option\u003cu32\u003e,\n}\n\npub trait ProgressCallback: Send {\n    fn on_progress(\u0026mut self, progress: \u0026TransferProgress);\n    fn on_complete(\u0026mut self, result: \u0026SyncResult);\n    fn on_error(\u0026mut self, error: \u0026str);\n}\n```\n\n### Operations to Enhance\n\n| Operation | Current | Enhancement | Progress Type |\n|-----------|---------|-------------|---------------|\n| `workers probe` (single) | Silent | Spinner | Spinner |\n| `workers probe --all` | \"Probing N workers...\" | Multi-line status | MultiProgress |\n| `workers benchmark` | \"Running benchmarks...\" | Per-worker progress | MultiProgress |\n| `daemon start` | Silent 2s wait | Spinner | Spinner |\n| `sync_to_remote` | Silent | Progress bar | ProgressBar |\n| `execute_remote` | Silent stream | Step + region | StepIndicator |\n| `retrieve_artifacts` | Silent | Progress bar | ProgressBar |\n\n### Mode-Specific Behavior\n\n| Mode | Behavior |\n|------|----------|\n| Human (TTY) | Full animated progress |\n| Plain (no color) | Static text updates: \"Syncing... 50%\" |\n| JSON | No progress display; optional progress events |\n| Quiet | No progress display |\n| Non-TTY (piped) | Line-based updates only |\n\n### JSON Progress Events (Optional Enhancement)\nFor scripting that needs progress info:\n```bash\nrch --json sync 2\u003e\u00261 | while read line; do\n  echo \"$line\" | jq -r '.progress.percent // empty'\ndone\n```\n```json\n{\"event\": \"progress\", \"phase\": \"sync\", \"percent\": 50, \"bytes\": 1234567}\n{\"event\": \"complete\", \"phase\": \"sync\", \"duration_ms\": 3200}\n```\n\n### Cancellation Handling (Ctrl+C)\n- Register signal handler\n- On SIGINT: stop spinners gracefully, show \"Cancelled\" message\n- Clean up partial state (don't leave half-synced files)\n- Exit with appropriate code (130 for SIGINT)\n\n### Performance Considerations\n- Update progress at most 10x/second (100ms debounce)\n- Don't update on every byte - batch updates\n- Spinner tick rate: 80ms (12.5 fps) - smooth without CPU waste\n\n### Files to Modify\n- `rch/src/ui/progress.rs` - new module wrapping indicatif\n- `rch/src/commands.rs` - add progress to probe, benchmark, daemon commands\n- `rch/src/transfer.rs` - add ProgressCallback parameter to sync functions\n- `rch/src/hook.rs` - add pipeline step indicators\n- `Cargo.toml` (rch) - add indicatif dependency\n\n### Progress Module API\n```rust\n// rch/src/ui/progress.rs\n\npub struct Spinner {\n    inner: ProgressBar,\n}\n\nimpl Spinner {\n    pub fn new(ctx: \u0026OutputContext, message: \u0026str) -\u003e Self;\n    pub fn set_message(\u0026self, msg: \u0026str);\n    pub fn finish_success(\u0026self, msg: \u0026str);  // âœ“ message\n    pub fn finish_error(\u0026self, msg: \u0026str);    // âœ— message\n    pub fn finish_warning(\u0026self, msg: \u0026str);  // âš  message\n}\n\npub struct ProgressBarWrapper {\n    inner: ProgressBar,\n}\n\nimpl ProgressBarWrapper {\n    pub fn new(ctx: \u0026OutputContext, total: u64, unit: \u0026str) -\u003e Self;\n    pub fn set_position(\u0026self, pos: u64);\n    pub fn set_message(\u0026self, msg: \u0026str);\n    pub fn finish(\u0026self);\n}\n\npub struct StepProgress {\n    current: usize,\n    total: usize,\n    steps: Vec\u003cStepStatus\u003e,\n}\n\nimpl StepProgress {\n    pub fn new(ctx: \u0026OutputContext, steps: \u0026[\u0026str]) -\u003e Self;\n    pub fn start_step(\u0026mut self, idx: usize);\n    pub fn complete_step(\u0026mut self, idx: usize, message: \u0026str);\n    pub fn fail_step(\u0026mut self, idx: usize, error: \u0026str);\n}\n\npub struct MultiProgressManager {\n    multi: MultiProgress,\n}\n\nimpl MultiProgressManager {\n    pub fn new(ctx: \u0026OutputContext) -\u003e Self;\n    pub fn add_spinner(\u0026self, key: \u0026str, message: \u0026str) -\u003e Spinner;\n    pub fn add_progress_bar(\u0026self, key: \u0026str, total: u64) -\u003e ProgressBarWrapper;\n}\n```\n\n## Testing Requirements\n\n### Unit Tests (`rch/src/ui/progress.rs`)\n```rust\n#[test]\nfn test_spinner_lifecycle() {\n    let (capture, ctx) = OutputCapture::new_non_tty();\n    let spinner = Spinner::new(\u0026ctx, \"Testing...\");\n    spinner.finish_success(\"Done\");\n    assert!(capture.stderr_string().contains(\"Done\"));\n}\n\n#[test]\nfn test_progress_bar_updates() {\n    let (capture, ctx) = OutputCapture::new_non_tty();\n    let bar = ProgressBarWrapper::new(\u0026ctx, 100, \"items\");\n    bar.set_position(50);\n    bar.finish();\n    // In non-TTY, should have line output\n    assert!(capture.stderr_string().contains(\"50\"));\n}\n\n#[test]\nfn test_no_progress_in_quiet_mode() {\n    let ctx = OutputContext::quiet();\n    let spinner = Spinner::new(\u0026ctx, \"Testing...\");\n    // Should be no-op\n}\n\n#[test]\nfn test_no_progress_in_json_mode() {\n    let ctx = OutputContext::json();\n    let spinner = Spinner::new(\u0026ctx, \"Testing...\");\n    // Should be no-op (or emit JSON events)\n}\n```\n\n### Integration Tests (`rch/tests/progress_integration.rs`)\n```rust\n#[tokio::test]\nasync fn test_probe_shows_progress() {\n    // Start daemon with mock\n    // Run probe command\n    // Verify stderr contains progress indicators\n}\n\n#[tokio::test]\nasync fn test_progress_completes_to_100() {\n    // Simulate transfer with progress callback\n    // Verify progress reaches 100%\n}\n\n#[test]\nfn test_progress_disabled_when_piped() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .env(\"RCH_MOCK_SSH\", \"1\")\n        .args([\"workers\", \"probe\", \"--all\"])\n        .stdout(Stdio::piped())  // Pipe stdout\n        .stderr(Stdio::piped())  // Capture stderr\n        .output()\n        .unwrap();\n    // stderr should have simple text, not ANSI animation sequences\n    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n    assert!(!stderr.contains(\"\\x1b[?25l\")); // Hide cursor (animation)\n}\n```\n\n### E2E Test Additions (`scripts/e2e_test.sh`)\n```bash\ntest_progress_indicators() {\n    log \"INFO\" \"PROGRESS\" \"Testing progress indicator behavior...\"\n\n    # Test spinner appears during probe\n    local stderr_file=\"$LOG_DIR/probe_stderr.txt\"\n    RCH_MOCK_SSH=1 \"$RCH\" workers probe mock-worker 2\u003e\"$stderr_file\"\n    if ! grep -q \"mock-worker\" \"$stderr_file\"; then\n        log \"FAIL\" \"PROGRESS\" \"No worker name in progress output\"\n        return 1\n    fi\n    log \"INFO\" \"PROGRESS\" \"Spinner test OK\"\n\n    # Test no animation codes when piped\n    local output\n    output=$(RCH_MOCK_SSH=1 \"$RCH\" workers probe --all 2\u003e\u00261 | cat)\n    # Check for cursor hide sequence (indicates animation attempted)\n    if echo \"$output\" | grep -q $'\\x1b\\[?25'; then\n        log \"FAIL\" \"PROGRESS\" \"Animation codes present in piped output\"\n        return 1\n    fi\n    log \"INFO\" \"PROGRESS\" \"Pipe detection OK\"\n\n    # Test progress completes without hanging (timeout)\n    if ! timeout 10 bash -c 'RCH_MOCK_SSH=1 '\"$RCH\"' workers probe --all 2\u003e\u00261' \u003e /dev/null; then\n        log \"FAIL\" \"PROGRESS\" \"Progress indicators caused hang\"\n        return 1\n    fi\n    log \"INFO\" \"PROGRESS\" \"No hang test OK\"\n}\n```\n\n### Manual Testing Checklist\n- [ ] Spinner animates smoothly (12.5 fps, no flicker)\n- [ ] Progress bar shows accurate percentage and speed\n- [ ] ETA is reasonable and updates\n- [ ] Multi-progress renders without flicker\n- [ ] Graceful handling of terminal resize\n- [ ] Ctrl+C cancels cleanly with message\n- [ ] Works correctly with small terminal (\u003c 80 cols)\n- [ ] No visual artifacts on completion\n\n## Acceptance Criteria\n- [ ] All long operations (\u003e500ms) have visual feedback\n- [ ] Spinner/progress bar lifecycle correct (start, update, finish)\n- [ ] indicatif integrated with consistent styling\n- [ ] rsync progress parsing works\n- [ ] Non-TTY mode produces reasonable text output\n- [ ] Quiet and JSON modes suppress progress\n- [ ] Cancellation handled gracefully\n- [ ] No flickering or visual artifacts\n- [ ] Progress + streaming output coexist\n- [ ] Unit test coverage \u003e85% for progress module\n- [ ] Integration tests pass\n- [ ] E2E tests pass including timeout test\n- [ ] Performance: \u003c1% CPU overhead from progress updates","status":"open","priority":1,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:36:31.800779644-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:07:57.380081018-05:00","dependencies":[{"issue_id":"remote_compilation_helper-5te","depends_on_id":"remote_compilation_helper-u0v","type":"blocks","created_at":"2026-01-16T11:58:39.62353985-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-5te","depends_on_id":"remote_compilation_helper-nbo","type":"blocks","created_at":"2026-01-16T11:58:39.692508281-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-62v","title":"Define CircuitState enum and CircuitBreakerConfig","description":"## Parent Epic: Circuit Breaker Pattern (remote_compilation_helper-9pw)\n\n## Task Description\n\nDefine the core types for the circuit breaker pattern: the CircuitState enum representing the three states, and CircuitBreakerConfig for tuning behavior.\n\n## Design\n\n### CircuitState Enum\n```rust\n// In rchd/src/health.rs or new rchd/src/circuit.rs\n\nuse std::time::{Duration, Instant};\nuse serde::{Deserialize, Serialize};\n\n/// Circuit breaker state for a worker\n#[derive(Debug, Clone)]\npub enum CircuitState {\n    /// Circuit closed - worker is healthy and accepting requests\n    /// This is the normal operating state.\n    Closed,\n    \n    /// Circuit open - worker has failed too many times\n    /// Worker is excluded from selection until cooldown expires.\n    Open {\n        /// When the circuit was tripped\n        tripped_at: Instant,\n        /// How many times this circuit has been tripped (for backoff calculation)\n        trip_count: u32,\n        /// When to attempt the next probe\n        next_probe_at: Instant,\n    },\n    \n    /// Circuit half-open - testing if worker has recovered\n    /// A single probe request is allowed through.\n    HalfOpen {\n        /// When we entered half-open state\n        entered_at: Instant,\n    },\n}\n\nimpl Default for CircuitState {\n    fn default() -\u003e Self {\n        CircuitState::Closed\n    }\n}\n\nimpl CircuitState {\n    /// Check if the circuit allows requests through\n    pub fn is_closed(\u0026self) -\u003e bool {\n        matches!(self, CircuitState::Closed)\n    }\n    \n    /// Check if the circuit is open (blocking requests)\n    pub fn is_open(\u0026self) -\u003e bool {\n        matches!(self, CircuitState::Open { .. })\n    }\n    \n    /// Check if we should probe (half-open or cooldown expired)\n    pub fn should_probe(\u0026self) -\u003e bool {\n        match self {\n            CircuitState::Closed =\u003e false,\n            CircuitState::Open { next_probe_at, .. } =\u003e Instant::now() \u003e= *next_probe_at,\n            CircuitState::HalfOpen { .. } =\u003e true,\n        }\n    }\n}\n```\n\n### CircuitBreakerConfig\n```rust\n/// Configuration for circuit breaker behavior\n#[derive(Debug, Clone)]\npub struct CircuitBreakerConfig {\n    /// Number of consecutive failures before tripping the circuit\n    /// Default: 3\n    pub failure_threshold: u32,\n    \n    /// Initial cooldown duration before first probe attempt\n    /// Default: 30 seconds\n    pub initial_cooldown: Duration,\n    \n    /// Maximum cooldown duration (caps exponential backoff)\n    /// Default: 5 minutes\n    pub max_cooldown: Duration,\n    \n    /// Multiplier for exponential backoff\n    /// Each trip: cooldown = min(initial * multiplier^trip_count, max)\n    /// Default: 2.0\n    pub backoff_multiplier: f64,\n    \n    /// Number of successful probes needed to close circuit\n    /// Default: 1\n    pub success_threshold: u32,\n}\n\nimpl Default for CircuitBreakerConfig {\n    fn default() -\u003e Self {\n        Self {\n            failure_threshold: 3,\n            initial_cooldown: Duration::from_secs(30),\n            max_cooldown: Duration::from_secs(300), // 5 minutes\n            backoff_multiplier: 2.0,\n            success_threshold: 1,\n        }\n    }\n}\n\nimpl CircuitBreakerConfig {\n    /// Calculate cooldown duration for given trip count\n    pub fn cooldown_for_trip(\u0026self, trip_count: u32) -\u003e Duration {\n        let multiplier = self.backoff_multiplier.powi(trip_count as i32);\n        let cooldown_secs = self.initial_cooldown.as_secs_f64() * multiplier;\n        let capped = cooldown_secs.min(self.max_cooldown.as_secs_f64());\n        Duration::from_secs_f64(capped)\n    }\n}\n```\n\n### Serializable Status (for API)\n```rust\n/// Serializable circuit state for status API\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CircuitStateInfo {\n    pub state: String,  // \"closed\", \"open\", \"half_open\"\n    pub trip_count: Option\u003cu32\u003e,\n    pub next_probe_in_secs: Option\u003cu64\u003e,\n}\n\nimpl From\u003c\u0026CircuitState\u003e for CircuitStateInfo {\n    fn from(state: \u0026CircuitState) -\u003e Self {\n        match state {\n            CircuitState::Closed =\u003e CircuitStateInfo {\n                state: \"closed\".to_string(),\n                trip_count: None,\n                next_probe_in_secs: None,\n            },\n            CircuitState::Open { trip_count, next_probe_at, .. } =\u003e {\n                let secs_until = next_probe_at\n                    .saturating_duration_since(Instant::now())\n                    .as_secs();\n                CircuitStateInfo {\n                    state: \"open\".to_string(),\n                    trip_count: Some(*trip_count),\n                    next_probe_in_secs: Some(secs_until),\n                }\n            },\n            CircuitState::HalfOpen { .. } =\u003e CircuitStateInfo {\n                state: \"half_open\".to_string(),\n                trip_count: None,\n                next_probe_in_secs: None,\n            },\n        }\n    }\n}\n```\n\n## Files to Modify/Create\n- `rchd/src/circuit.rs` (new file) OR extend `rchd/src/health.rs`\n- `rchd/src/lib.rs` or `rchd/src/main.rs` (module declaration)\n\n## Testing\n```rust\n#[test]\nfn test_circuit_state_default_is_closed() {\n    let state = CircuitState::default();\n    assert!(state.is_closed());\n}\n\n#[test]\nfn test_circuit_config_cooldown_calculation() {\n    let config = CircuitBreakerConfig::default();\n    // Trip 0: 30s\n    assert_eq!(config.cooldown_for_trip(0), Duration::from_secs(30));\n    // Trip 1: 60s\n    assert_eq!(config.cooldown_for_trip(1), Duration::from_secs(60));\n    // Trip 2: 120s\n    assert_eq!(config.cooldown_for_trip(2), Duration::from_secs(120));\n    // Trip 5: would be 960s but capped at 300s\n    assert_eq!(config.cooldown_for_trip(5), Duration::from_secs(300));\n}\n\n#[test]\nfn test_should_probe_logic() {\n    // Closed: never probe\n    let closed = CircuitState::Closed;\n    assert!(!closed.should_probe());\n    \n    // Open with future probe time: don't probe\n    let open_future = CircuitState::Open {\n        tripped_at: Instant::now(),\n        trip_count: 1,\n        next_probe_at: Instant::now() + Duration::from_secs(60),\n    };\n    assert!(!open_future.should_probe());\n    \n    // Half-open: always probe\n    let half_open = CircuitState::HalfOpen {\n        entered_at: Instant::now(),\n    };\n    assert!(half_open.should_probe());\n}\n```\n\n## Acceptance Criteria\n- [ ] CircuitState enum with Closed, Open, HalfOpen variants\n- [ ] CircuitBreakerConfig with sensible defaults\n- [ ] Cooldown calculation with exponential backoff and cap\n- [ ] should_probe() logic correct for all states\n- [ ] CircuitStateInfo for API serialization\n- [ ] Unit tests pass\n\n## Estimated Effort: 1-2 hours","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:09:35.732427882-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:09:35.732427882-05:00"}
{"id":"remote_compilation_helper-7ds","title":"Epic: Rich rch status Command for Operational Visibility","description":"## Overview\n\nImplement a comprehensive `rch status` command that shows the complete state of the RCH system at a glance: daemon health, worker status, slot availability, recent build history, and any issues requiring attention.\n\n## Problem Statement\n\nUsers currently have limited visibility into RCH's operational state:\n- Is the daemon running?\n- Which workers are healthy vs degraded?\n- Why did my build fail or run slowly?\n- Is RCH actually being used for my builds?\n\nWithout observability, users can't diagnose issues or build confidence in the system.\n\n## Goals\n\n1. Show daemon status (running, pid, uptime)\n2. Show all workers with health, slots, speed scores\n3. Show recent build history (last N builds with outcomes)\n4. Highlight any issues requiring attention\n5. Support both human-readable and JSON output formats\n\n## Design\n\n### CLI Interface\n```bash\nrch status                    # Summary view\nrch status --workers          # Detailed worker view\nrch status --jobs             # Recent builds focus\nrch status --json             # Machine-readable output\nrch status --watch            # Auto-refresh every 2s (future)\n```\n\n### Sample Output\n```\n$ rch status --workers\n\nRCH Status\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nDaemon: âœ“ Running (pid 12345, uptime 2d 4h)\nSocket: /tmp/rch.sock\nConfig: ~/.config/rch/config.toml\n\nWorkers (2 healthy, 1 degraded, 0 unreachable):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Worker       â”‚ Status     â”‚ Slots     â”‚ Speed   â”‚ Last Check â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ fast-builder â”‚ âœ“ Healthy  â”‚ 12/16     â”‚ 94.2    â”‚ 5s ago     â”‚\nâ”‚ gpu-worker   â”‚ âœ“ Healthy  â”‚ 4/8       â”‚ 87.1    â”‚ 8s ago     â”‚\nâ”‚ old-server   â”‚ âš  Degraded â”‚ 0/4       â”‚ 45.3    â”‚ 3s ago     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nRecent Builds (last 5):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Time       â”‚ Project                     â”‚ Worker       â”‚ Result â”‚ Duration â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 2m ago     â”‚ remote_compilation_helper   â”‚ fast-builder â”‚ âœ“      â”‚ 34.2s    â”‚\nâ”‚ 5m ago     â”‚ my_project                  â”‚ gpu-worker   â”‚ âœ“      â”‚ 12.1s    â”‚\nâ”‚ 8m ago     â”‚ my_project                  â”‚ fast-builder â”‚ âœ— 101  â”‚ 8.3s     â”‚\nâ”‚ 15m ago    â”‚ other_project               â”‚ gpu-worker   â”‚ âœ“      â”‚ 45.7s    â”‚\nâ”‚ 22m ago    â”‚ my_project                  â”‚ fast-builder â”‚ âœ“      â”‚ 11.9s    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nIssues:\n  âš  Worker 'old-server' is degraded (response time 5.2s \u003e 5s threshold)\n\nTips:\n  Run 'rch workers probe old-server' to diagnose the degraded worker\n```\n\n### Daemon API Extension\n```rust\n// New endpoint: GET /status\nstruct StatusResponse {\n    daemon: DaemonStatus,\n    workers: Vec\u003cWorkerStatusInfo\u003e,\n    recent_builds: Vec\u003cBuildRecord\u003e,\n    issues: Vec\u003cIssue\u003e,\n}\n\nstruct DaemonStatus {\n    pid: u32,\n    uptime_secs: u64,\n    socket_path: String,\n    config_path: String,\n}\n\nstruct WorkerStatusInfo {\n    id: String,\n    host: String,\n    status: WorkerStatus,\n    used_slots: u32,\n    total_slots: u32,\n    speed_score: f64,\n    last_health_check: DateTime\u003cUtc\u003e,\n    circuit_state: Option\u003cCircuitState\u003e,  // After circuit breaker epic\n}\n\nstruct BuildRecord {\n    timestamp: DateTime\u003cUtc\u003e,\n    project_id: String,\n    worker_id: String,\n    command: String,\n    exit_code: i32,\n    duration_ms: u64,\n}\n```\n\n### Build History Tracking\n- Daemon maintains in-memory ring buffer of last 100 builds\n- Each build recorded: timestamp, project, worker, command, exit code, duration\n- Optional: persist to disk for survival across daemon restarts\n\n## Rationale\n\nThis is ranked #3 of 5 improvements because:\n- Essential operational tooling - every production system needs observability\n- Builds user confidence - can verify RCH is working correctly\n- Enables self-service debugging - users diagnose their own issues\n- Professional polish - quality CLI output signals quality software\n- Foundation for future monitoring/alerting\n\n## Success Criteria\n\n- [ ] `rch status` shows daemon and worker summary\n- [ ] `rch status --workers` shows detailed worker table\n- [ ] `rch status --jobs` shows recent build history\n- [ ] `rch status --json` outputs valid JSON\n- [ ] Issues/warnings are highlighted clearly\n- [ ] Output is colorized and well-formatted\n- [ ] Works when daemon is down (shows \"daemon not running\")\n- [ ] All existing tests pass\n\n## Estimated Effort: 2-3 days\n\n## Dependencies: Circuit Breaker epic (to show circuit states in worker status)","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:06:19.357573016-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:06:19.357573016-05:00"}
{"id":"remote_compilation_helper-7nj","title":"Add circuit breaker integration tests and E2E scenarios","description":"## Parent Epic: Circuit Breaker Pattern (remote_compilation_helper-9pw)\n\n## Task Description\n\nCreate comprehensive tests for the circuit breaker implementation, including unit tests for state transitions, integration tests for the full flow, and E2E scenarios.\n\n## Test Categories\n\n### 1. State Transition Unit Tests\n```rust\n#[cfg(test)]\nmod circuit_tests {\n    use super::*;\n    \n    #[test]\n    fn test_closed_to_open_after_failures() {\n        // N consecutive failures trips the circuit\n    }\n    \n    #[test]\n    fn test_open_to_half_open_after_cooldown() {\n        // Circuit enters half-open when cooldown expires\n    }\n    \n    #[test]\n    fn test_half_open_to_closed_on_success() {\n        // Successful probe closes the circuit\n    }\n    \n    #[test]\n    fn test_half_open_to_open_on_failure() {\n        // Failed probe re-trips with increased backoff\n    }\n    \n    #[test]\n    fn test_exponential_backoff_capped() {\n        // Backoff doesn't exceed max_cooldown\n    }\n    \n    #[test]\n    fn test_success_resets_failure_count() {\n        // Success while closed resets consecutive failures\n    }\n}\n```\n\n### 2. Health Monitor Integration Tests\n```rust\n#[tokio::test]\nasync fn test_health_monitor_trips_circuit() {\n    // Setup mock that fails N times\n    // Verify circuit transitions to Open\n}\n\n#[tokio::test]\nasync fn test_health_monitor_skips_open_circuit() {\n    // Worker with open circuit\n    // Verify no health check until probe time\n}\n\n#[tokio::test]\nasync fn test_health_monitor_probes_at_cooldown() {\n    // Open circuit with expired cooldown\n    // Verify probe is attempted\n}\n\n#[tokio::test]\nasync fn test_health_monitor_closes_circuit_on_recovery() {\n    // Worker recovers during probe\n    // Verify circuit closes\n}\n```\n\n### 3. Selection Integration Tests\n```rust\n#[tokio::test]\nasync fn test_selection_excludes_open_circuit_workers() {\n    // Mix of healthy and open-circuit workers\n    // Verify only healthy selected\n}\n\n#[tokio::test]\nasync fn test_selection_returns_all_circuits_open() {\n    // All workers have open circuits\n    // Verify correct reason returned\n}\n```\n\n### 4. E2E Scenarios\n\nAdd to `scripts/e2e_test.sh`:\n```bash\n# Test circuit breaker scenarios\n\n# Scenario: Worker fails repeatedly, circuit opens\nrun_scenario \"circuit_trip\" \"allow\" \"circuit-trip\"\n# - Start with healthy mock worker\n# - Configure mock to fail after first success\n# - Run multiple commands\n# - Verify fallback to local after circuit trips\n\n# Scenario: Circuit recovery\nrun_scenario \"circuit_recovery\" \"deny\" \"circuit-recovery\"\n# - Start with open circuit mock\n# - Configure mock to succeed\n# - Wait for cooldown\n# - Verify worker is used again\n\n# Scenario: All circuits open\nrun_scenario \"all_circuits_open\" \"allow\" \"all-circuits-open\"\n# - All workers have open circuits\n# - Verify local fallback with correct reason\n```\n\n### 5. Mock Infrastructure Extensions\n```rust\n// Extend MockConfig for circuit testing\n\nimpl MockConfig {\n    /// Fail after N successful calls (for testing circuit trip)\n    pub fn fail_after(n: u32) -\u003e Self {\n        Self {\n            fail_after_count: Some(n),\n            ..Self::default()\n        }\n    }\n    \n    /// Alternate success/failure (for testing flapping)\n    pub fn alternate() -\u003e Self {\n        Self {\n            alternate_results: true,\n            ..Self::default()\n        }\n    }\n}\n```\n\n### 6. Observability Tests\n```rust\n#[tokio::test]\nasync fn test_circuit_state_in_status_api() {\n    // Worker with open circuit\n    // Query /status endpoint\n    // Verify circuit state in response\n}\n\n#[tokio::test]\nasync fn test_circuit_state_logging() {\n    // Trip circuit\n    // Verify warning log emitted\n    // Close circuit\n    // Verify info log emitted\n}\n```\n\n## Files to Modify\n- `rchd/src/health.rs` (test module)\n- `rchd/src/selection.rs` (test module)\n- `rch-common/src/mock.rs` (extend MockConfig)\n- `scripts/e2e_test.sh` (add scenarios)\n\n## Acceptance Criteria\n- [ ] All state transition unit tests pass\n- [ ] Health monitor integration tests pass\n- [ ] Selection integration tests pass\n- [ ] E2E circuit trip scenario passes\n- [ ] E2E circuit recovery scenario passes\n- [ ] E2E all-circuits-open scenario passes\n- [ ] Mock infrastructure extended\n- [ ] Circuit state visible in status API\n- [ ] Logging tests verify expected output\n\n## Dependencies\n- Requires: All previous circuit breaker tasks\n\n## Estimated Effort: 3-4 hours","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:11:55.485643153-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:11:55.485643153-05:00","dependencies":[{"issue_id":"remote_compilation_helper-7nj","depends_on_id":"remote_compilation_helper-ova","type":"blocks","created_at":"2026-01-16T12:12:01.998451-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-8ht","title":"Implement rch CLI subcommand handlers","notes":"Expanded CLI epic covers all subcommands; keep this issue as active implementation track. If your current work already implements some subcommands, mark progress there and close corresponding child tasks.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:58:31.902861769-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:27:08.659087805-05:00","closed_at":"2026-01-16T09:27:08.659087805-05:00","close_reason":"Duplicate of ei5.3.1 - CLI subcommand handlers implemented","dependencies":[{"issue_id":"remote_compilation_helper-8ht","depends_on_id":"remote_compilation_helper-ei5.3","type":"parent-child","created_at":"2026-01-16T09:13:19.773419586-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-9pw","title":"Epic: Circuit Breaker Pattern with Auto-Recovery","description":"## Overview\n\nImplement the circuit breaker pattern for worker health management. After N consecutive failures, \"trip\" the circuit and stop sending requests to that worker. After a cool-down period, enter \"half-open\" state and probe the worker. If probe succeeds, reset to healthy; if probe fails, re-trip the circuit.\n\n## Problem Statement\n\nCurrent health check behavior:\n- Workers marked `Unreachable` after 3 consecutive failures\n- Health checks continue running for all workers\n- No backoff between checks for failing workers\n- Recovery may not be smooth - worker could flap between states\n\nProblems with current approach:\n- Failing workers continue receiving health checks at same rate (wastes resources)\n- No \"soft\" recovery testing before returning worker to full rotation\n- Status can flap rapidly if worker is intermittently available\n- No exponential backoff means sustained load on failing infrastructure\n\n## Goals\n\n1. Implement circuit breaker state machine (Closed â†’ Open â†’ Half-Open)\n2. Add exponential backoff for health checks on open circuits\n3. Probe workers in half-open state before full recovery\n4. Integrate circuit state with worker selection (skip open circuits)\n5. Expose circuit state in status API\n\n## Design\n\n### State Machine\n```\n                    success\n                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                â”‚                                       â”‚\n                â–¼                                       â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  N failures  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  cooldown   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ CLOSED (Healthy)   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ OPEN         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ HALF_OPEN   â”‚\nâ”‚ Normal operation   â”‚              â”‚ Skip worker  â”‚             â”‚ Probe only  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜\n        â–²                                  â–²                           â”‚\n        â”‚                                  â”‚ probe failure             â”‚\n        â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n        â”‚                                                              â”‚\n        â”‚                       probe success                          â”‚\n        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### State Definitions\n```rust\n#[derive(Debug, Clone)]\npub enum CircuitState {\n    /// Normal operation - worker accepts requests\n    Closed,\n    /// Circuit tripped - worker excluded from selection\n    Open {\n        tripped_at: Instant,\n        failure_count: u32,\n        next_probe_at: Instant,\n    },\n    /// Testing recovery - single probe request allowed\n    HalfOpen {\n        entered_at: Instant,\n    },\n}\n```\n\n### Configuration\n```rust\npub struct CircuitBreakerConfig {\n    /// Failures before tripping circuit\n    failure_threshold: u32,        // default: 3\n    /// Initial cooldown before half-open\n    initial_cooldown: Duration,    // default: 30s\n    /// Max cooldown (exponential backoff cap)\n    max_cooldown: Duration,        // default: 5min\n    /// Backoff multiplier\n    backoff_multiplier: f64,       // default: 2.0\n    /// Successes needed to close circuit\n    success_threshold: u32,        // default: 1\n}\n```\n\n### Health Check Integration\n```rust\nasync fn check_worker_with_circuit(\n    worker: \u0026WorkerState,\n    circuit: \u0026mut CircuitState,\n    config: \u0026CircuitBreakerConfig,\n) -\u003e HealthCheckResult {\n    match circuit {\n        CircuitState::Closed =\u003e {\n            // Normal health check\n            let result = check_worker_health(worker).await;\n            if !result.healthy {\n                // Track failure, possibly trip\n            }\n            result\n        }\n        CircuitState::Open { next_probe_at, .. } =\u003e {\n            if Instant::now() \u003e= *next_probe_at {\n                // Transition to half-open\n                *circuit = CircuitState::HalfOpen { entered_at: Instant::now() };\n                // Fall through to probe\n            } else {\n                // Skip check, circuit still open\n                return HealthCheckResult::skipped();\n            }\n        }\n        CircuitState::HalfOpen { .. } =\u003e {\n            // Probe check\n            let result = check_worker_health(worker).await;\n            if result.healthy {\n                *circuit = CircuitState::Closed;\n            } else {\n                // Re-trip with increased backoff\n                *circuit = CircuitState::Open { /* ... */ };\n            }\n            result\n        }\n    }\n}\n```\n\n### Selection Integration\n```rust\npub async fn select_worker(...) -\u003e Option\u003cArc\u003cWorkerState\u003e\u003e {\n    let candidates = pool.healthy_workers().await\n        .into_iter()\n        .filter(|w| {\n            // Exclude workers with open circuits\n            let circuit = get_circuit_state(\u0026w.config.id);\n            !matches!(circuit, CircuitState::Open { .. })\n        })\n        .collect();\n    // ... rest of selection logic\n}\n```\n\n## Rationale\n\nThis is ranked #4 of 5 improvements because:\n- Industry-standard reliability pattern proven in distributed systems\n- Prevents cascading failures - one bad worker doesn't poison the pool\n- Self-healing - system recovers automatically when workers return\n- Reduces alert fatigue - workers flap less, status is more stable\n- Essential for production scale - manual intervention shouldn't be required\n\n## Edge Cases\n\n1. **All workers open**: Should trigger local fallback (depends on Local Fallback epic)\n2. **Rapid recovery/failure**: Half-open state prevents rapid flapping\n3. **Network partition heals**: Workers recover automatically via probing\n4. **Manual intervention**: `rch workers enable \u003cid\u003e` could force circuit closed\n\n## Success Criteria\n\n- [ ] CircuitState enum implemented with all three states\n- [ ] Health checks respect circuit state\n- [ ] Exponential backoff increases cooldown on repeated trips\n- [ ] Half-open probing works correctly\n- [ ] Worker selection excludes open circuits\n- [ ] Circuit state exposed in status API\n- [ ] Manual circuit reset possible via CLI\n- [ ] All existing tests pass\n- [ ] New tests cover all state transitions\n\n## Estimated Effort: 2-3 days\n\n## Dependencies: None (enhances existing health monitoring)","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:07:00.89564336-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:07:00.89564336-05:00"}
{"id":"remote_compilation_helper-ac7","title":"Implement worker configuration system (workers.toml)","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:46:12.570030987-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T08:48:27.672771503-05:00","closed_at":"2026-01-16T08:48:27.672771503-05:00","close_reason":"Implemented worker configuration system: rchd/src/config.rs with TOML-based workers.toml and daemon.toml support. Loads workers at daemon startup and populates WorkerPool. 4 new tests, all 43 tests pass."}
{"id":"remote_compilation_helper-alo","title":"Improve error messages with actionable suggestions and help links","description":"## Overview\nTransform technical error messages into user-friendly diagnostics with context, suggestions, and help resources. Users should be able to self-diagnose and fix issues.\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-nbo (colors) - error display uses colors\n\n## Requirements\n\n### Error Display Format\n```\nâœ— Error: Could not connect to daemon\n\n  The daemon socket was not found at /tmp/rch.sock.\n  This usually means the daemon is not running.\n\n  Quick fixes:\n    1. Start the daemon: rch daemon start\n    2. Check if another instance is running: pgrep rchd\n    3. Verify socket path: echo $RCH_SOCKET_PATH\n\n  For more help: https://github.com/your/repo/wiki/Troubleshooting#daemon\n```\n\n### Crate Consideration\nConsider using `miette` crate for beautiful diagnostics:\n- Automatic source code snippets for config errors\n- Colored error display with context\n- Suggestion system built-in\n- OR implement custom display with similar structure\n\n### Error Categories and Messages\n\n#### Connection Errors\n| Error | Current Message | Enhanced Message |\n|-------|-----------------|------------------|\n| Daemon not running | \"Daemon socket not found\" | Full diagnostic with start command |\n| Worker unreachable | \"Connection failed\" | Include SSH debug hints, host check |\n| SSH auth failed | \"Permission denied\" | Suggest checking key path, permissions |\n\n#### Configuration Errors  \n| Error | Current Message | Enhanced Message |\n|-------|-----------------|------------------|\n| Missing workers.toml | \"No workers configured\" | Path, creation command, link to docs |\n| Invalid TOML | \"Parse error\" | Line number, expected format, example |\n| Invalid value | \"confidence_threshold should be...\" | Current value, valid range, default |\n\n#### Runtime Errors\n| Error | Current Message | Enhanced Message |\n|-------|-----------------|------------------|\n| rsync failed | \"rsync failed with exit code\" | Common causes, rsync install check |\n| Compilation failed | exit code only | Suggest checking remote logs |\n\n### Implementation\n\n1. Create `rch/src/errors.rs` module:\n```rust\npub struct RchError {\n    pub kind: ErrorKind,\n    pub message: String,\n    pub context: Option\u003cString\u003e,\n    pub suggestions: Vec\u003cString\u003e,\n    pub help_url: Option\u003cString\u003e,\n}\n\nimpl RchError {\n    pub fn display(\u0026self, mode: OutputMode) -\u003e String { ... }\n}\n```\n\n2. Define ErrorKind enum covering all error types\n\n3. Create constructors for common errors:\n```rust\nRchError::daemon_not_running(socket_path: \u0026str) -\u003e Self\nRchError::worker_unreachable(worker_id: \u0026str, host: \u0026str) -\u003e Self\nRchError::config_parse_error(path: \u0026Path, line: usize, msg: \u0026str) -\u003e Self\n```\n\n4. Update all error sites to use RchError\n\n### Files to Modify\n- Create `rch/src/errors.rs` - error types and display\n- `rch/src/commands.rs` - replace anyhow errors with RchError\n- `rch/src/hook.rs` - update hook errors\n- `rch/src/transfer.rs` - update transfer errors\n- `rch/src/config.rs` - update config parsing errors\n\n## Testing Requirements\n\n### Unit Tests\n- Test each error type produces correct format\n- Test suggestions are appropriate for each error\n- Test Plain mode (no colors) error display\n- Test JSON mode error serialization\n\n### Integration Tests\n- Trigger each error condition and verify message\n- Test error chaining (inner errors included)\n\n### E2E Test Additions\n```bash\n# Scenario: error_messages\n# Trigger known error conditions and verify helpful output\n\n# Test daemon not running error\nrun_scenario \"error_daemon_not_running\" \"verify_error\" \"\"\n\n# Test worker unreachable error  \nrun_scenario \"error_worker_unreachable\" \"verify_error\" \"worker-down\"\n\n# Test config error\nrun_scenario \"error_invalid_config\" \"verify_error\" \"bad-config\"\n```\n\n### Logging\n- Log full error chain at DEBUG level\n- Log user-friendly message at ERROR level\n- Include timestamp and context for debugging\n\n## Acceptance Criteria\n- [ ] All error messages include actionable suggestions\n- [ ] Error display is visually clear and easy to scan\n- [ ] Common errors have specific, helpful messages\n- [ ] JSON mode outputs structured error data\n- [ ] Unit tests cover all error types\n- [ ] E2E tests verify error scenarios","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:36:33.103970136-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:58:41.072631042-05:00","dependencies":[{"issue_id":"remote_compilation_helper-alo","depends_on_id":"remote_compilation_helper-nbo","type":"blocks","created_at":"2026-01-16T11:59:05.809708699-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ayn","title":"Epic: Automatic Toolchain Version Synchronization","description":"## Overview\n\nImplement automatic Rust toolchain version synchronization between local machine and remote workers. Before executing compilation on a worker, RCH ensures the worker has the exact same rustc/cargo version as local. This is the #1 ranked improvement idea.\n\n## Problem Statement\n\nToolchain version mismatches between local and remote cause cryptic compilation failures:\n- Edition mismatches: \"error: expected identifier, found keyword `async`\"\n- Feature mismatches: \"error[E0658]: use of unstable library feature\"\n- ABI mismatches: Linking errors, segfaults in tests\n- Warning differences: CI fails when worker has stricter warnings\n\nThese errors are confusing because the same code compiles locally but fails remotely.\n\n## Goals\n\n1. Automatically detect local Rust toolchain version\n2. Verify worker has matching toolchain before compilation\n3. Install/switch to correct toolchain using rustup if needed\n4. Cache toolchain availability to avoid repeated checks\n5. Graceful handling when toolchain sync fails (fallback to local)\n\n## Design\n\n### Version Detection (Hook Side)\n```rust\n// Capture at classification time\nlet local_toolchain = capture_local_toolchain()?;\n// Format: \"nightly-2024-01-15\" or \"stable-1.75.0\" or \"1.76.0-nightly (abc123 2024-01-15)\"\n```\n\n### Protocol Extension\n```rust\nstruct SelectionRequest {\n    project_id: String,\n    required_cores: u32,\n    toolchain: Option\u003cString\u003e,  // NEW: Required toolchain version\n    // ...\n}\n\nstruct ExecutionRequest {\n    command: String,\n    working_dir: PathBuf,\n    toolchain: Option\u003cString\u003e,  // NEW: Toolchain to use\n    // ...\n}\n```\n\n### Worker Agent Logic\n```rust\nasync fn ensure_toolchain(required: \u0026str) -\u003e Result\u003c()\u003e {\n    let current = run(\"rustc --version\").await?;\n    if !versions_compatible(current, required) {\n        // Try to switch to existing toolchain\n        if run(format!(\"rustup run {} rustc --version\", required)).await.is_ok() {\n            // Toolchain exists, will use rustup run\n            return Ok(());\n        }\n        // Install the toolchain\n        run(format!(\"rustup install {}\", required)).await?;\n    }\n    Ok(())\n}\n```\n\n### Execution Wrapper\n```bash\n# Instead of: cargo build\n# Execute: rustup run nightly-2024-01-15 cargo build\n```\n\n### Caching Strategy\n- Worker agent caches available toolchains in memory\n- Refresh cache on toolchain install\n- Cache invalidation: periodic refresh or on \"toolchain not found\" errors\n- Optional: Daemon tracks worker toolchain availability\n\n## Rationale\n\nThis is ranked #1 of 5 improvements because:\n- ELIMINATES an entire class of frustrating, confusing failures\n- Completely transparent - users don't think about worker toolchains\n- Aligns with RCH's core philosophy of transparency\n- Leverages rustup which is ubiquitous in Rust ecosystem\n- Low risk implementation with massive UX improvement\n\n## Edge Cases\n\n1. **Worker doesn't have rustup**: Log warning, attempt compilation anyway, fallback to local on failure\n2. **Toolchain installation fails**: Log error, fallback to local execution\n3. **Network issues during install**: Timeout and fallback\n4. **Disk space on worker**: Check available space, warn if low\n5. **Very old/custom toolchains**: May not be in rustup, graceful degradation\n\n## Success Criteria\n\n- [ ] Local rustc version is captured correctly for all toolchain types\n- [ ] Worker verifies toolchain before compilation\n- [ ] Missing toolchains are installed automatically\n- [ ] Toolchain availability is cached efficiently\n- [ ] Fallback to local works when sync impossible\n- [ ] All existing tests pass\n- [ ] New tests cover version detection, sync, and edge cases\n\n## Estimated Effort: 2-3 days\n\n## Dependencies: Local Fallback epic (for graceful degradation)","status":"open","priority":1,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:05:27.660369027-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:05:27.660369027-05:00"}
{"id":"remote_compilation_helper-b9p","title":"Add --json output flag for machine-readable output","description":"## Overview\nAdd --json flag for machine-readable output, enabling scripting, automation, and integration with other tools (jq, monitoring systems, CI pipelines).\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-u0v (UI output abstraction layer - defines Json OutputMode)\n\n**Can be worked in PARALLEL with nbo (colors) after u0v completes.**\n\n## Requirements\n\n### Global Flag\n```rust\n#[arg(long, global = true, help = \"Output in JSON format\")]\njson: bool,\n```\n\n### JSON Envelope Standard\nALL JSON output follows a consistent envelope for forward compatibility:\n\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"status\",\n  \"success\": true,\n  \"data\": { ... },\n  \"error\": null\n}\n```\n\n**Fields:**\n- `version`: Schema version (string) - increment on breaking changes\n- `command`: Command that produced this output\n- `success`: Boolean indicating command success\n- `data`: Command-specific payload (null on error)\n- `error`: Error object (null on success)\n\n### Error Format\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"workers probe\",\n  \"success\": false,\n  \"data\": null,\n  \"error\": {\n    \"code\": \"WORKER_UNREACHABLE\",\n    \"message\": \"Could not connect to worker gpu-1\",\n    \"details\": {\n      \"worker_id\": \"gpu-1\",\n      \"host\": \"gpu1.internal\",\n      \"cause\": \"Connection refused\"\n    },\n    \"suggestions\": [\n      \"Check that the worker is running\",\n      \"Verify SSH key permissions\",\n      \"Run: rch doctor\"\n    ]\n  }\n}\n```\n\n**Error codes (non-exhaustive):**\n- `DAEMON_NOT_RUNNING`\n- `WORKER_UNREACHABLE`\n- `CONFIG_INVALID`\n- `CONFIG_NOT_FOUND`\n- `SSH_AUTH_FAILED`\n- `RSYNC_FAILED`\n- `INTERNAL_ERROR`\n\n### Commands with JSON Output\n\n#### `rch status --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"status\",\n  \"success\": true,\n  \"data\": {\n    \"daemon\": {\n      \"running\": true,\n      \"socket\": \"/tmp/rch.sock\",\n      \"uptime_seconds\": 3600,\n      \"pid\": 12345\n    },\n    \"workers\": {\n      \"total\": 3,\n      \"by_status\": {\n        \"healthy\": 2,\n        \"degraded\": 1,\n        \"unreachable\": 0,\n        \"disabled\": 0\n      }\n    },\n    \"hook\": {\n      \"installed\": true,\n      \"settings_path\": \"/home/user/.claude/settings.json\"\n    }\n  },\n  \"error\": null\n}\n```\n\n#### `rch workers list --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"workers list\",\n  \"success\": true,\n  \"data\": {\n    \"workers\": [\n      {\n        \"id\": \"gpu-1\",\n        \"host\": \"gpu1.internal\",\n        \"user\": \"ubuntu\",\n        \"identity_file\": \"~/.ssh/id_rsa\",\n        \"status\": \"healthy\",\n        \"total_slots\": 64,\n        \"available_slots\": 32,\n        \"priority\": 100,\n        \"tags\": [\"gpu\", \"fast\"]\n      }\n    ],\n    \"total\": 1\n  },\n  \"error\": null\n}\n```\n\n#### `rch workers probe --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"workers probe\",\n  \"success\": true,\n  \"data\": {\n    \"results\": [\n      {\n        \"worker_id\": \"gpu-1\",\n        \"host\": \"gpu1.internal\",\n        \"success\": true,\n        \"latency_ms\": 45,\n        \"error\": null\n      },\n      {\n        \"worker_id\": \"cpu-1\",\n        \"host\": \"cpu1.internal\",\n        \"success\": false,\n        \"latency_ms\": null,\n        \"error\": \"Connection refused\"\n      }\n    ],\n    \"summary\": {\n      \"total\": 2,\n      \"succeeded\": 1,\n      \"failed\": 1\n    }\n  },\n  \"error\": null\n}\n```\n\n#### `rch config show --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"config show\",\n  \"success\": true,\n  \"data\": {\n    \"config\": {\n      \"general\": {\n        \"enabled\": true,\n        \"log_level\": \"info\",\n        \"socket_path\": \"/tmp/rch.sock\"\n      },\n      \"compilation\": {\n        \"confidence_threshold\": 0.85,\n        \"min_local_time_ms\": 2000\n      },\n      \"transfer\": {\n        \"compression_level\": 3,\n        \"exclude_patterns\": [\"target/\", \".git/\"]\n      }\n    },\n    \"sources\": {\n      \"config_file\": \"/home/user/.config/rch/config.toml\",\n      \"workers_file\": \"/home/user/.config/rch/workers.toml\",\n      \"env_overrides\": [\"RCH_LOG_LEVEL\"]\n    }\n  },\n  \"error\": null\n}\n```\n\n#### `rch config validate --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"config validate\",\n  \"success\": true,\n  \"data\": {\n    \"valid\": true,\n    \"files_checked\": [\n      {\"path\": \"~/.config/rch/config.toml\", \"valid\": true},\n      {\"path\": \"~/.config/rch/workers.toml\", \"valid\": true}\n    ],\n    \"errors\": [],\n    \"warnings\": [\n      {\n        \"file\": \"config.toml\",\n        \"line\": 5,\n        \"field\": \"compression_level\",\n        \"message\": \"Value 20 exceeds recommended maximum of 19\",\n        \"severity\": \"warning\"\n      }\n    ]\n  },\n  \"error\": null\n}\n```\n\n#### `rch daemon status --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"daemon status\",\n  \"success\": true,\n  \"data\": {\n    \"running\": true,\n    \"socket\": \"/tmp/rch.sock\",\n    \"pid\": 12345,\n    \"uptime_seconds\": 3600,\n    \"version\": \"0.1.0\"\n  },\n  \"error\": null\n}\n```\n\n#### `rch doctor --json`\n```json\n{\n  \"version\": \"1\",\n  \"command\": \"doctor\",\n  \"success\": true,\n  \"data\": {\n    \"checks\": [\n      {\n        \"category\": \"prerequisites\",\n        \"name\": \"rsync\",\n        \"status\": \"pass\",\n        \"message\": \"rsync 3.2.7 at /usr/bin/rsync\"\n      },\n      {\n        \"category\": \"workers\",\n        \"name\": \"gpu-1\",\n        \"status\": \"warning\",\n        \"message\": \"Slow response: 2340ms\"\n      }\n    ],\n    \"summary\": {\n      \"passed\": 8,\n      \"warnings\": 1,\n      \"failed\": 0,\n      \"overall\": \"healthy_with_warnings\"\n    }\n  },\n  \"error\": null\n}\n```\n\n### Exit Codes in JSON Mode\nJSON mode still uses meaningful exit codes for scripting:\n- `0`: Success\n- `1`: Command failed (error in JSON)\n- `2`: Usage/argument error\n- `3`: Configuration error\n- `10`: Daemon not running\n- `11`: Worker unreachable\n- `130`: Interrupted (Ctrl+C)\n\n### Implementation\n\n#### JSON Output Types (`rch/src/json_types.rs`)\n```rust\nuse serde::Serialize;\n\n#[derive(Serialize)]\npub struct JsonEnvelope\u003cT: Serialize\u003e {\n    pub version: \u0026'static str,\n    pub command: String,\n    pub success: bool,\n    pub data: Option\u003cT\u003e,\n    pub error: Option\u003cJsonError\u003e,\n}\n\n#[derive(Serialize)]\npub struct JsonError {\n    pub code: String,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    pub suggestions: Vec\u003cString\u003e,\n}\n\nimpl\u003cT: Serialize\u003e JsonEnvelope\u003cT\u003e {\n    pub fn success(command: \u0026str, data: T) -\u003e Self { ... }\n    pub fn error(command: \u0026str, error: JsonError) -\u003e Self { ... }\n}\n\n// Per-command data types\n#[derive(Serialize)]\npub struct StatusData { ... }\n\n#[derive(Serialize)]\npub struct WorkersListData { ... }\n\n// etc.\n```\n\n#### Command Pattern\n```rust\npub async fn workers_list(ctx: \u0026OutputContext) -\u003e Result\u003c()\u003e {\n    let workers = load_workers()?;\n\n    if ctx.is_json() {\n        let data = WorkersListData::from(\u0026workers);\n        ctx.json(\u0026JsonEnvelope::success(\"workers list\", data))?;\n        return Ok(());\n    }\n\n    // Human-readable output...\n}\n```\n\n#### Error Handling Pattern\n```rust\npub async fn workers_probe(ctx: \u0026OutputContext, worker_id: \u0026str) -\u003e Result\u003c()\u003e {\n    match do_probe(worker_id).await {\n        Ok(result) =\u003e {\n            if ctx.is_json() {\n                ctx.json(\u0026JsonEnvelope::success(\"workers probe\", result))?;\n            } else {\n                ctx.success(\u0026format!(\"Worker {} OK ({}ms)\", worker_id, result.latency));\n            }\n            Ok(())\n        }\n        Err(e) =\u003e {\n            if ctx.is_json() {\n                ctx.json(\u0026JsonEnvelope::\u003c()\u003e::error(\n                    \"workers probe\",\n                    JsonError {\n                        code: \"WORKER_UNREACHABLE\".into(),\n                        message: e.to_string(),\n                        details: Some(json!({\"worker_id\": worker_id})),\n                        suggestions: vec![\"Check worker connectivity\".into()],\n                    },\n                ))?;\n                std::process::exit(11);\n            }\n            Err(e)\n        }\n    }\n}\n```\n\n### Files to Modify\n- Create `rch/src/json_types.rs` - JSON envelope and data types\n- `rch/src/main.rs` - add --json global flag\n- `rch/src/ui/context.rs` - add JSON output method with envelope wrapping\n- `rch/src/commands.rs` - update all commands with JSON branches\n- `rch-common/src/types.rs` - add Serialize to existing types\n\n## Testing Requirements\n\n### Unit Tests (`rch/src/json_types.rs`)\n```rust\n#[test]\nfn test_json_envelope_success() {\n    let envelope = JsonEnvelope::success(\"test\", json!({\"foo\": \"bar\"}));\n    let json = serde_json::to_string(\u0026envelope).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(parsed[\"version\"], \"1\");\n    assert_eq!(parsed[\"success\"], true);\n    assert!(parsed[\"error\"].is_null());\n}\n\n#[test]\nfn test_json_envelope_error() {\n    let envelope = JsonEnvelope::\u003c()\u003e::error(\"test\", JsonError {\n        code: \"TEST_ERROR\".into(),\n        message: \"Something failed\".into(),\n        details: None,\n        suggestions: vec![],\n    });\n    let json = serde_json::to_string(\u0026envelope).unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(\u0026json).unwrap();\n    assert_eq!(parsed[\"success\"], false);\n    assert!(parsed[\"data\"].is_null());\n    assert_eq!(parsed[\"error\"][\"code\"], \"TEST_ERROR\");\n}\n\n#[test]\nfn test_all_json_types_serialize() {\n    // Ensure all JSON data types can serialize without panic\n    let _ = serde_json::to_string(\u0026StatusData::default()).unwrap();\n    let _ = serde_json::to_string(\u0026WorkersListData::default()).unwrap();\n    // ... etc\n}\n```\n\n### Integration Tests (`rch/tests/json_integration.rs`)\n```rust\n#[test]\nfn test_all_commands_json_valid() {\n    for cmd in \u0026[\"status\", \"workers list\", \"config show\", \"daemon status\"] {\n        let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n            .args([\"--json\"])\n            .args(cmd.split_whitespace())\n            .output()\n            .expect(\"failed to run\");\n\n        let json: serde_json::Value = serde_json::from_slice(\u0026output.stdout)\n            .expect(\u0026format!(\"{} did not produce valid JSON\", cmd));\n\n        assert!(json[\"version\"].is_string(), \"{} missing version\", cmd);\n        assert!(json[\"success\"].is_boolean(), \"{} missing success\", cmd);\n    }\n}\n\n#[test]\nfn test_json_error_has_code() {\n    // Trigger an error condition\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .args([\"--json\", \"workers\", \"probe\", \"nonexistent-worker\"])\n        .output()\n        .expect(\"failed to run\");\n\n    let json: serde_json::Value = serde_json::from_slice(\u0026output.stdout).unwrap();\n    assert_eq!(json[\"success\"], false);\n    assert!(json[\"error\"][\"code\"].is_string());\n}\n\n#[test]\nfn test_json_exit_codes() {\n    // Successful command\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .args([\"--json\", \"config\", \"show\"])\n        .output()\n        .unwrap();\n    assert_eq!(output.status.code(), Some(0));\n\n    // Error command should have non-zero exit\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .args([\"--json\", \"workers\", \"probe\", \"nonexistent\"])\n        .output()\n        .unwrap();\n    assert_ne!(output.status.code(), Some(0));\n}\n```\n\n### E2E Test Additions (`scripts/e2e_test.sh`)\n```bash\ntest_json_output() {\n    log \"INFO\" \"JSON\" \"Testing JSON output format...\"\n\n    # Test all commands produce valid JSON with envelope\n    local commands=(\n        \"status\"\n        \"workers list\"\n        \"config show\"\n        \"daemon status\"\n    )\n\n    for cmd in \"${commands[@]}\"; do\n        local output\n        output=$(\"$RCH\" --json $cmd 2\u003e\u00261)\n\n        # Must be valid JSON\n        if ! echo \"$output\" | jq . \u003e /dev/null 2\u003e\u00261; then\n            log \"FAIL\" \"JSON\" \"'$cmd' produced invalid JSON\"\n            return 1\n        fi\n\n        # Must have version field\n        if ! echo \"$output\" | jq -e '.version' \u003e /dev/null 2\u003e\u00261; then\n            log \"FAIL\" \"JSON\" \"'$cmd' missing version field\"\n            return 1\n        fi\n\n        # Must have success field\n        if ! echo \"$output\" | jq -e '.success' \u003e /dev/null 2\u003e\u00261; then\n            log \"FAIL\" \"JSON\" \"'$cmd' missing success field\"\n            return 1\n        fi\n\n        log \"INFO\" \"JSON\" \"'$cmd' OK\"\n    done\n\n    # Test error produces valid JSON error\n    local error_output\n    error_output=$(\"$RCH\" --json workers probe nonexistent-worker 2\u003e\u00261) || true\n    if ! echo \"$error_output\" | jq -e '.error.code' \u003e /dev/null 2\u003e\u00261; then\n        log \"FAIL\" \"JSON\" \"Error missing error.code field\"\n        return 1\n    fi\n    log \"INFO\" \"JSON\" \"Error format OK\"\n\n    log \"INFO\" \"JSON\" \"All JSON tests passed\"\n}\n```\n\n### Schema Documentation\nCreate `docs/json-schema.md` documenting:\n- Envelope format\n- All command outputs\n- Error codes\n- Version history\n\n## Acceptance Criteria\n- [ ] --json flag works globally on all commands\n- [ ] All output follows envelope format with version\n- [ ] Error output includes code, message, suggestions\n- [ ] Exit codes are meaningful in JSON mode\n- [ ] All JSON types can serialize (unit tests)\n- [ ] Integration tests verify all commands\n- [ ] E2E tests verify envelope structure\n- [ ] Documentation exists for JSON schema\n- [ ] Version field allows future schema evolution","status":"open","priority":2,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:03.672228669-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:09:06.362793119-05:00","dependencies":[{"issue_id":"remote_compilation_helper-b9p","depends_on_id":"remote_compilation_helper-u0v","type":"blocks","created_at":"2026-01-16T11:59:35.192422114-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-btf","title":"Add interactive config initialization wizard","description":"## Overview\nTransform config initialization from silent file creation into an interactive wizard that guides users through setup with validation and helpful prompts.\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-nbo (colors) - wizard uses colored prompts\n- **BLOCKED BY**: remote_compilation_helper-cmj (status indicators) - uses indicators for validation\n\n## Requirements\n\n### Crate Selection\nUse `dialoguer` crate for interactive prompts:\n- Input fields with validation\n- Confirmation prompts\n- Select lists\n- Theme customization\n\n### Interactive Flow\n\n```\n$ rch config init\n\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚  RCH Configuration Wizard                                   â”‚\nâ”‚  Let's set up your remote compilation workers.              â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n\nğŸ“ Step 1/4: Worker Configuration\n\n? Worker ID (unique name for this worker): gpu-worker\n? SSH hostname or IP: gpu.internal.company.com\n? SSH username: ubuntu\n? SSH identity file path: ~/.ssh/id_rsa\n\n  Validating connection...\n  âœ“ SSH connection successful (45ms)\n\n? Add another worker? (y/N): n\n\nğŸ“ Step 2/4: Compilation Settings\n\n? Minimum local compile time to intercept (ms) [2000]:\n? Confidence threshold (0.0-1.0) [0.85]:\n\nğŸ“ Step 3/4: Transfer Settings\n\n? Compression level (1-19, higher = slower but smaller) [3]:\n? Additional exclude patterns (comma-separated, empty for defaults):\n\nğŸ“ Step 4/4: Confirmation\n\nConfiguration Summary:\n  Workers:     1 configured (gpu-worker)\n  Threshold:   2000ms / 85% confidence\n  Compression: Level 3\n\n? Write configuration? (Y/n): y\n\nâœ“ Created: ~/.config/rch/config.toml\nâœ“ Created: ~/.config/rch/workers.toml\n\nNext steps:\n  1. Start the daemon:  rch daemon start\n  2. Install the hook:  rch hook install\n  3. Check status:      rch status\n```\n\n### Non-Interactive Mode\nFor CI/scripting, support flags:\n```bash\nrch config init --non-interactive \\\n  --worker-id=gpu-1 \\\n  --worker-host=gpu.internal \\\n  --worker-user=ubuntu \\\n  --worker-key=~/.ssh/id_rsa\n```\n\nOr accept a config file:\n```bash\nrch config init --from-file=my-workers.toml\n```\n\n### Validation During Input\n- Worker ID: non-empty, valid characters\n- Hostname: valid hostname/IP format\n- SSH key: file exists, proper permissions\n- Confidence: 0.0-1.0 range\n- Compression: 1-19 range\n\n### Optional: Connection Test\nAfter entering worker details, offer to test:\n```\n? Test SSH connection to gpu-worker? (Y/n): y\n  Connecting to gpu.internal...\n  âœ“ Connection successful (45ms)\n  âœ“ rsync available on remote\n```\n\n### Files to Modify\n- `rch/src/commands.rs` - expand config_init() function\n- `rch/src/main.rs` - add flags for non-interactive mode\n- `Cargo.toml` (rch) - add dialoguer dependency\n\n### Code Structure\n```rust\npub async fn config_init(\n    non_interactive: bool,\n    worker_id: Option\u003cString\u003e,\n    worker_host: Option\u003cString\u003e,\n    worker_user: Option\u003cString\u003e,\n    worker_key: Option\u003cString\u003e,\n) -\u003e Result\u003c()\u003e {\n    if non_interactive {\n        return config_init_non_interactive(...);\n    }\n    config_init_interactive().await\n}\n\nasync fn config_init_interactive() -\u003e Result\u003c()\u003e {\n    // Use dialoguer for prompts\n    let worker_id: String = Input::with_theme(\u0026theme())\n        .with_prompt(\"Worker ID\")\n        .validate_with(|input: \u0026String| {\n            if input.is_empty() {\n                Err(\"Worker ID cannot be empty\")\n            } else {\n                Ok(())\n            }\n        })\n        .interact_text()?;\n\n    // ... continue with other prompts\n}\n```\n\n## Testing Requirements\n\n### Unit Tests\n- Test validation functions (hostname, range checks, etc.)\n- Test config file generation from input\n- Test non-interactive mode with various flag combinations\n\n### Integration Tests\n- Test full interactive flow with mocked input\n- Test non-interactive mode creates valid config\n- Test validation rejects invalid input\n\n### E2E Test Additions\n```bash\n# Test non-interactive mode\ntest_config_init_non_interactive() {\n    local temp_dir\n    temp_dir=$(mktemp -d)\n\n    # Run non-interactive init\n    RCH_CONFIG_DIR=\"$temp_dir\" rch config init \\\n        --non-interactive \\\n        --worker-id=test-worker \\\n        --worker-host=test.host \\\n        --worker-user=testuser \\\n        --worker-key=~/.ssh/id_rsa\n\n    # Verify files created\n    [[ -f \"$temp_dir/workers.toml\" ]] || die \"workers.toml not created\"\n\n    # Verify content\n    grep -q \"test-worker\" \"$temp_dir/workers.toml\" || die \"Worker ID not in config\"\n\n    log \"INFO\" \"CONFIG\" \"Non-interactive init OK\"\n    # Clean up temp directory after test\n}\n```\n\n### Manual Testing\n- [ ] Run full interactive wizard\n- [ ] Test each validation message\n- [ ] Test connection testing feature\n- [ ] Test cancellation (Ctrl+C) at each step\n- [ ] Test non-interactive with all flags\n- [ ] Test with missing required flags (should error clearly)\n\n## Acceptance Criteria\n- [ ] Interactive wizard guides user through all settings\n- [ ] Input validation with helpful error messages\n- [ ] Optional connection testing\n- [ ] Non-interactive mode for automation\n- [ ] Creates valid configuration files\n- [ ] Colored output matching theme\n- [ ] Unit tests for validation logic\n- [ ] E2E tests for non-interactive mode\n- [ ] Graceful Ctrl+C handling","status":"open","priority":3,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:17.463952233-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:02:36.752193682-05:00","dependencies":[{"issue_id":"remote_compilation_helper-btf","depends_on_id":"remote_compilation_helper-nbo","type":"blocks","created_at":"2026-01-16T12:02:43.264255984-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-btf","depends_on_id":"remote_compilation_helper-cmj","type":"blocks","created_at":"2026-01-16T12:02:43.359005211-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ceb","title":"Bug: Daemon health checks don't respect RCH_MOCK_SSH mode","description":"When RCH_MOCK_SSH=1 is set, the daemon's health check still tries to make real SSH connections, causing mock workers to be marked unhealthy. This breaks E2E tests in mock mode. Fix: Daemon should check RCH_MOCK_SSH and skip real health checks, marking workers as healthy in mock mode.","status":"closed","priority":1,"issue_type":"bug","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:21:31.483079134-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:27:52.958905075-05:00","closed_at":"2026-01-16T11:27:52.958905075-05:00","close_reason":"Added debug logging to health check. Issue was that the daemon binary hadn't been rebuilt after mock mode implementation changes. E2E tests now pass consistently."}
{"id":"remote_compilation_helper-cmj","title":"Standardize status indicators (âœ“/âœ—/âš ) across all commands","description":"## Overview\nStandardize status indicator symbols and their meanings across ALL commands. Ensure visual consistency and immediate recognizability.\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-nbo (colors) - indicators need color support\n\n## Requirements\n\n### Standard Status Indicators\nDefine enum in ui.rs:\n```rust\npub enum StatusIndicator {\n    Success,    // âœ“ (green) - operation succeeded, healthy state\n    Error,      // âœ— (red) - operation failed, error state\n    Warning,    // âš  (yellow) - degraded, needs attention\n    Info,       // â— (cyan) - neutral information\n    Pending,    // â—‹ (gray) - waiting, not started\n    InProgress, // â— (blue) - currently running\n    Disabled,   // âŠ˜ (gray) - intentionally disabled\n}\n```\n\n### Application Mapping\n\n| Context | Current | Should Be |\n|---------|---------|-----------|\n| Worker healthy | \"OK\" or \"âœ“\" | âœ“ (green) |\n| Worker unreachable | \"âœ—\" | âœ— (red) |\n| Worker degraded | varies | âš  (yellow) |\n| Worker disabled | plain text | âŠ˜ (gray) |\n| Daemon running | \"Status: Running\" | âœ“ Running (green) |\n| Daemon stopped | \"Status: Not running\" | âœ— Stopped (red) |\n| Config valid | \"âœ“\" | âœ“ Valid (green) |\n| Config warning | \"âš \" | âš  with explanation (yellow) |\n| Config error | \"âœ—\" | âœ— with explanation (red) |\n| Hook installed | plain text | âœ“ Installed (green) |\n| Hook not installed | plain text | â—‹ Not installed (gray) |\n| Probe success | \"âœ“ OK (100ms)\" | âœ“ 100ms (green) |\n| Probe failed | \"âœ— Error: ...\" | âœ— Error message (red) |\n\n### Implementation\n1. Create `StatusIndicator::display(\u0026self, mode: OutputMode) -\u003e String` method\n2. Update ALL status displays in commands.rs to use StatusIndicator\n3. Ensure consistent spacing after indicators\n\n### Files to Modify\n- `rch/src/ui.rs` - add StatusIndicator enum and display logic\n- `rch/src/commands.rs` - update all status displays (lines 176, 179, 182, 188, 228, 231, 234, 240, 312-327, 629-687, 696-703, 873-908)\n\n## Testing Requirements\n\n### Unit Tests\n- Test each StatusIndicator produces correct symbol and color\n- Test Plain mode produces symbols without ANSI codes\n- Test JSON mode produces structured status\n\n### Integration Tests\n- Snapshot tests for status command output\n- Verify all status displays use the standard indicators\n\n### E2E Test Additions\n```bash\n# Scenario: status_indicators\n# Verify consistent indicators across commands\nrun_scenario \"status_consistency\" \"verify\" \"\"\n```\n\n## Acceptance Criteria\n- [ ] All commands use StatusIndicator enum\n- [ ] No hardcoded status symbols remain in commands.rs\n- [ ] Visual consistency verified across all commands\n- [ ] Unit tests cover all indicator types\n- [ ] Snapshot tests capture expected output format","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:36:34.370314322-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:57:46.648417643-05:00","dependencies":[{"issue_id":"remote_compilation_helper-cmj","depends_on_id":"remote_compilation_helper-nbo","type":"blocks","created_at":"2026-01-16T11:58:14.488091447-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5","title":"RCH Core TODOs Master Plan (Hook + WorkerPool + CLI + Tests)","description":"Background\n- RCH is a transparent compilation offloading system; the hook must be fast, precise, and fail-open.\n- The current codebase has core scaffolding; this plan captures the remaining high-leverage TODOs in a self-contained way.\n\nScope\n- Hook integration (classification â†’ daemon â†’ transfer pipeline â†’ artifacts)\n- WorkerPool correctness (counting, status, health recovery)\n- rch CLI commands (daemon/workers/status/config/hook) with clear UX\n- Comprehensive tests (unit/integration/e2e) + detailed logging\n\nNon-Goals\n- New features beyond the above TODOs (e.g., UI, metrics, autoscaling)\n\nPrinciples\n- Fail-open: errors in remote pipeline must allow local execution.\n- Precision over recall for classification; correctness over cleverness.\n- Observability: log enough to debug without overwhelming normal output.","design":"This master epic decomposes three top TODO areas into actionable, dependency-aware tasks, plus a testing epic. The structure allows parallel work while preserving ordering constraints (e.g., CLI tests depend on CLI implementations). Each task includes background, goal, and acceptance to minimize future ambiguity.","acceptance_criteria":"- All child epics are created, linked, and contain granular tasks with dependencies.\n- Each task contains enough context to implement without re-reading the long plan document.\n- Test tasks explicitly cover unit, integration, and e2e with logging expectations.","notes":"If any task is already implemented in HEAD, verify by code inspection + tests, then close with a note referencing evidence.","status":"closed","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.056378843-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T10:42:09.690778309-05:00","closed_at":"2026-01-16T10:42:09.690778309-05:00","close_reason":"All child epics completed: Hook pipeline, WorkerPool, CLI commands, and Testing/E2E coverage"}
{"id":"remote_compilation_helper-ei5.1","title":"Hook: Remote Execution Pipeline","description":"Purpose\n- Complete the hook execution flow end-to-end: classify â†’ select worker â†’ transfer â†’ remote exec â†’ artifact return.\n- Enforce fail-open semantics and avoid double-execution.\n\nKey Risks\n- Latency regressions in hook path.\n- Incorrect deny/allow decisions causing duplicate execution or blocked commands.\n- Artifact return correctness for Rust targets.","design":"Hook must remain a thin orchestrator; state lives in daemon or transfer pipeline. Prefer small helpers and explicit error handling. Keep stdout semantics aligned with Claude Code hook expectations (empty output = allow).","acceptance_criteria":"- Hook pipeline is fully functional with remote execution and artifact retrieval.\n- Fail-open behavior is preserved when any remote stage fails.\n- Unit + integration tests exist for the hook pipeline.","notes":"If remote pipeline already exists in HEAD, verify all stages (sync/exec/artifacts) and ensure tests cover failure modes.","status":"closed","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.131789506-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:40:07.874951999-05:00","closed_at":"2026-01-16T09:40:07.874951999-05:00","close_reason":"All child tasks complete: TransferPipeline integration, config application, protocol-safe output, and tests","dependencies":[{"issue_id":"remote_compilation_helper-ei5.1","depends_on_id":"remote_compilation_helper-ei5","type":"parent-child","created_at":"2026-01-16T09:13:18.133611567-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.1.1","title":"Hook: integrate TransferPipeline for remote compilation","description":"Background\n- Hook currently classifies commands and selects a worker. It must then orchestrate transfer, remote exec, and artifact return.\n\nGoals\n- Wire TransferPipeline into hook flow (sync â†’ exec â†’ artifacts).\n- Preserve fail-open if any stage errors.\n- Stream remote stdout/stderr to the agent (stderr preferred).\n\nImplementation Notes\n- Use `TransferPipeline::new`, `sync_to_remote`, `execute_remote_streaming`, `retrieve_artifacts`.\n- Deny local execution after successful remote run to avoid double compile.\n- Ensure exit codes propagate meaningfully to hook output.","design":"Keep hook code minimal; pipeline complexity stays in transfer module. Ensure minimal allocations and avoid blocking operations in the hook.","acceptance_criteria":"- Remote compilation is executed for classified commands.\n- Artifacts returned into local target/.\n- Any pipeline failure results in allow/local execution.\n- Streaming output visible to agent during remote execution.","notes":"Verified in rch/src/hook.rs that TransferPipeline is integrated: execute_remote_compilation builds pipeline, runs sync_to_remote, execute_remote_streaming, and retrieve_artifacts with fail-open handling.","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.441152283-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:17:09.135510493-05:00","closed_at":"2026-01-16T09:17:09.135510493-05:00","close_reason":"Implemented in rch/src/hook.rs (TransferPipeline wired end-to-end)","dependencies":[{"issue_id":"remote_compilation_helper-ei5.1.1","depends_on_id":"remote_compilation_helper-ei5.1","type":"parent-child","created_at":"2026-01-16T09:13:18.442637219-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.1.2","title":"Hook: apply config (threshold, socket path, transfer settings)","description":"Background\n- Hook has hardcoded confidence threshold and socket path.\n\nGoals\n- Load RchConfig (user + project + env overrides).\n- Apply confidence threshold, socket path, and transfer settings.\n- Respect global enable/disable flags.\n\nConsiderations\n- Config loading must be fast; cache if necessary.\n- If config parsing fails, fail-open to local execution.","design":"Prefer a single `load_config()` call per hook invocation; avoid repeated filesystem reads where possible.","acceptance_criteria":"- Hook uses config values for threshold and socket path.\n- Config errors are non-fatal and lead to allow/local execution.\n- Unit tests cover env overrides and project config precedence.","notes":"Implemented config usage in rch/src/hook.rs: load_config with fail-open on error, check general.enabled, use compilation.confidence_threshold, use general.socket_path for daemon query, and pass transfer settings into TransferPipeline.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.523018409-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:21:39.388184953-05:00","closed_at":"2026-01-16T09:21:39.388184953-05:00","close_reason":"Hook now loads config for threshold/socket/transfer with fail-open","dependencies":[{"issue_id":"remote_compilation_helper-ei5.1.2","depends_on_id":"remote_compilation_helper-ei5.1","type":"parent-child","created_at":"2026-01-16T09:13:18.524698803-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.1.2","depends_on_id":"remote_compilation_helper-ei5.1.1","type":"blocks","created_at":"2026-01-16T09:13:19.277779164-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.1.3","title":"Hook: enforce protocol-safe output + streaming behavior","description":"Background\n- Claude Code hook protocol expects empty stdout to allow; JSON output to deny.\n\nGoals\n- Ensure hook outputs are correct and consistent for success/failure.\n- Include clear deny reasons when remote compilation is used.\n- Avoid noisy output to stdout in allow path.\n\nConsiderations\n- Streaming should go to stderr; stdout reserved for hook response.","design":"Treat stdout as control channel; stderr as data channel.","acceptance_criteria":"- Allow path produces empty stdout.\n- Deny path includes JSON with clear reason.\n- Streaming output uses stderr only.","notes":"Verified in rch/src/hook.rs: allow path emits no stdout; deny path emits JSON only. execute_remote_compilation streams both stdout/stderr via eprintln (stderr), keeping stdout reserved for hook protocol.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.608172004-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:17:50.036604733-05:00","closed_at":"2026-01-16T09:17:50.036604733-05:00","close_reason":"Hook output/streaming behavior already protocol-safe","dependencies":[{"issue_id":"remote_compilation_helper-ei5.1.3","depends_on_id":"remote_compilation_helper-ei5.1","type":"parent-child","created_at":"2026-01-16T09:13:18.609561079-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.1.3","depends_on_id":"remote_compilation_helper-ei5.1.1","type":"blocks","created_at":"2026-01-16T09:13:19.321808261-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.1.4","title":"Hook: unit + integration tests (mocked pipeline)","description":"Background\n- Hook logic should be testable without real SSH workers.\n\nGoals\n- Add unit tests for hook decision paths.\n- Add integration test for daemon socket request/response (mock server).\n- Add mock pipeline for transfer/ssh to validate sequencing.\n\nLogging\n- Tests should emit clear phase logs for debug (sync/exec/artifacts).","design":"Prefer deterministic mocks; avoid real network/rsync in unit tests.","acceptance_criteria":"- Unit tests cover classification allow/deny and config thresholds.\n- Integration tests validate daemon request parsing and response handling.\n- Mocked pipeline verifies proper sequencing and fail-open behavior.","notes":"Align test logs with e2e script logs to simplify troubleshooting.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.689802807-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:39:50.673405109-05:00","closed_at":"2026-01-16T09:39:50.673405109-05:00","close_reason":"Hook unit and integration tests added covering classification, daemon communication, and fail-open behavior","dependencies":[{"issue_id":"remote_compilation_helper-ei5.1.4","depends_on_id":"remote_compilation_helper-ei5.1","type":"parent-child","created_at":"2026-01-16T09:13:18.690998939-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.1.4","depends_on_id":"remote_compilation_helper-ei5.1.1","type":"blocks","created_at":"2026-01-16T09:13:19.363360404-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.1.4","depends_on_id":"remote_compilation_helper-ei5.1.2","type":"blocks","created_at":"2026-01-16T09:13:19.403126415-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.2","title":"WorkerPool: Correctness \u0026 Health","description":"Purpose\n- Ensure WorkerPool accounting and status mutation are correct and thread-safe.\n- Health monitor should allow unreachable workers to recover.\n\nKey Risks\n- Incorrect availability leading to overcommit or starvation.\n- Workers stuck in unreachable state forever.","design":"Use interior mutability (RwLock or atomics) for status; avoid blocking slow paths. Health should poll all workers to allow recovery.","acceptance_criteria":"- WorkerPool length reflects actual workers.\n- Worker status can be updated safely; health monitor checks all workers.\n- Tests validate status transitions and selection behavior.","notes":"If fixes are already merged, ensure tests capture the regressions that prompted the fixes.","status":"closed","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.203900478-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:32:01.725935525-05:00","closed_at":"2026-01-16T09:32:01.725935525-05:00","close_reason":"All child tasks completed: WorkerPool length accounting (ei5.2.1), status mutation + health recovery (ei5.2.2), and selection tests (ei5.2.3). All 26 rchd tests pass.","dependencies":[{"issue_id":"remote_compilation_helper-ei5.2","depends_on_id":"remote_compilation_helper-ei5","type":"parent-child","created_at":"2026-01-16T09:13:18.205775207-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.2.1","title":"WorkerPool: accurate length accounting","description":"Background\n- WorkerPool must report actual worker count and be safe for concurrent access.\n\nGoals\n- Implement accurate len() using AtomicUsize or async lock-based length.\n- Ensure add/remove paths keep count correct.\n\nConsiderations\n- Keep read access fast (no full lock unless necessary).","design":"If using atomic counters, ensure increments happen only when inserting a new worker.","acceptance_criteria":"- len() reflects real worker count.\n- Tests demonstrate len() increments on add and remains stable.","notes":"Verified in rchd/src/workers.rs: WorkerPool tracks worker_count via AtomicUsize, incremented on insert; len() reads worker_count; all_workers() exists for health monitoring.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.757207118-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:17:16.658002273-05:00","closed_at":"2026-01-16T09:17:16.658002273-05:00","close_reason":"Worker count tracking implemented in rchd/src/workers.rs","dependencies":[{"issue_id":"remote_compilation_helper-ei5.2.1","depends_on_id":"remote_compilation_helper-ei5.2","type":"parent-child","created_at":"2026-01-16T09:13:18.758765271-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.2.2","title":"WorkerPool: status mutation + health recovery","description":"Background\n- Worker status must be mutable and visible to selection and health systems.\n\nGoals\n- Add interior mutability for status (RwLock or atomics).\n- Health monitor should check all workers (not just healthy) to allow recovery.\n- Ensure selection only uses healthy workers.","design":"Avoid holding locks during long operations; update status after health check completes.","acceptance_criteria":"- set_status updates state safely and is reflected in selection.\n- Health monitor evaluates all workers each interval.\n- Tests cover transition to degraded/unreachable and recovery.","notes":"Verified in rchd/src/workers.rs: WorkerState status uses RwLock with async getters/setters; WorkerPool set_status updates state. rchd/src/health.rs checks all_workers each interval, enabling recovery from unreachable.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.825333559-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:17:42.473822962-05:00","closed_at":"2026-01-16T09:17:42.473822962-05:00","close_reason":"Status mutability + health recovery implemented","dependencies":[{"issue_id":"remote_compilation_helper-ei5.2.2","depends_on_id":"remote_compilation_helper-ei5.2","type":"parent-child","created_at":"2026-01-16T09:13:18.827199061-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.2.2","depends_on_id":"remote_compilation_helper-ei5.2.1","type":"blocks","created_at":"2026-01-16T09:13:19.443859928-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.2.3","title":"Worker selection: healthy-only + slot-aware tests","description":"Background\n- Selection must respect worker health and slot availability.\n\nGoals\n- Ensure selection filters unhealthy workers.\n- Validate reservation and release paths via tests.","design":"Keep selection deterministic; prefer explicit weights and clear logs.","acceptance_criteria":"- Selection ignores degraded/unreachable workers.\n- Unit tests validate scoring and filtering behavior.","notes":"If selection already correct, add tests to lock it in.","status":"closed","priority":3,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.892304494-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:31:41.871695987-05:00","closed_at":"2026-01-16T09:31:41.871695987-05:00","close_reason":"Selection tests exist and pass: test_select_worker_ignores_unhealthy verifies unhealthy workers are filtered, test_select_worker_respects_slot_availability verifies slot availability is respected. All 3 selection tests pass.","dependencies":[{"issue_id":"remote_compilation_helper-ei5.2.3","depends_on_id":"remote_compilation_helper-ei5.2","type":"parent-child","created_at":"2026-01-16T09:13:18.894054418-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.2.3","depends_on_id":"remote_compilation_helper-ei5.2.2","type":"blocks","created_at":"2026-01-16T09:13:19.483083537-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.3","title":"rch CLI: Full Command Implementations","description":"Purpose\n- Implement rch CLI subcommands so operators can manage daemon, workers, config, and hook.\n- Provide clear human-readable output with optional JSON support.\n\nKey Risks\n- Incomplete or misleading output makes debugging difficult.\n- Commands that mutate system state must be explicit and safe.","design":"Keep CLI thin: prefer calling daemon APIs or shared config helpers. Avoid long-running operations in the hook process. Ensure consistent output formatting across commands.","acceptance_criteria":"- All CLI subcommands in rch/main.rs are implemented (no TODO stubs remain).\n- Each command has clear output and error handling.\n- Tests exist for key command paths and input validation.","notes":"There is an in-progress issue for CLI handlers; reparent it under this epic and expand scope/acceptance to cover all subcommands.","status":"closed","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.277356722-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:31:16.758359063-05:00","closed_at":"2026-01-16T09:31:16.758359063-05:00","close_reason":"All child tasks completed: CLI subcommand handlers implemented (ei5.3.1), unit+integration tests added (ei5.3.2). All rch CLI commands functional with tests.","dependencies":[{"issue_id":"remote_compilation_helper-ei5.3","depends_on_id":"remote_compilation_helper-ei5","type":"parent-child","created_at":"2026-01-16T09:13:18.278577901-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.3.1","title":"rch CLI: implement all subcommand handlers","description":"Background\n- rch CLI currently stubs most subcommands; operators need full workflow coverage.\n\nGoals\n- Implement daemon, workers, status, config, and hook commands.\n- Provide friendly text output and optional JSON for automation.\n\nConsiderations\n- Commands should surface clear errors (daemon down, config missing, etc.).\n- Use shared config loaders and daemon socket API instead of duplicating logic.","design":"Prefer small helper functions per subcommand; avoid long match arms.","acceptance_criteria":"- All subcommand handlers implemented with real functionality.\n- Commands produce consistent, human-readable output with optional JSON.\n- Validation ensures safe mutations (e.g., hook install/uninstall).","notes":"There is an existing in-progress issue for CLI handlers. Reparent it under this epic and expand its description to cover all subcommands.","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.958970175-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:27:07.244901109-05:00","closed_at":"2026-01-16T09:27:07.244901109-05:00","close_reason":"Implemented all CLI subcommand handlers in rch/src/commands.rs: workers (list/probe/benchmark/drain/enable), daemon (start/stop/restart/status/logs), config (show/init/validate/set), hook (install/uninstall/test), and status commands. All 63 tests pass.","dependencies":[{"issue_id":"remote_compilation_helper-ei5.3.1","depends_on_id":"remote_compilation_helper-ei5.3","type":"parent-child","created_at":"2026-01-16T09:13:18.960204679-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.3.2","title":"rch CLI: unit + integration tests","description":"Background\n- CLI behavior needs tests to avoid regressions.\n\nGoals\n- Unit tests for parsing and validation logic.\n- Integration tests for socket interactions using mock daemon.\n- Golden output tests for `status` and `workers list` output.\n\nLogging\n- Tests should log command args and outputs for debugging.","design":"Use temp dirs for config file tests; avoid touching real user configs.","acceptance_criteria":"- Tests cover at least one path per subcommand.\n- Mock daemon tests validate error handling and JSON parsing.\n- Golden outputs are stable and documented.","notes":"Coordinate with hook tests to reuse mock daemon components.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:19.030320134-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:32:09.72456541-05:00","closed_at":"2026-01-16T09:32:09.72456541-05:00","close_reason":"Added 11 CLI tests covering TOML parsing, config validation, worker config conversion, and command classification","dependencies":[{"issue_id":"remote_compilation_helper-ei5.3.2","depends_on_id":"remote_compilation_helper-ei5.3","type":"parent-child","created_at":"2026-01-16T09:13:19.031842099-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.3.2","depends_on_id":"remote_compilation_helper-ei5.3.1","type":"blocks","created_at":"2026-01-16T09:13:19.528382144-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.4","title":"Testing \u0026 E2E Coverage","description":"Purpose\n- Add comprehensive tests and e2e scripts with logging so pipeline correctness is verifiable.\n- Ensure tests cover failure modes and fail-open behavior.\n\nKey Risks\n- Flaky tests due to network/SSH variability.\n- Insufficient logging makes debugging failures slow.","design":"Prefer deterministic mocks for CI; keep real-worker tests opt-in. Log both structured and human-readable output with timestamps and phases.","acceptance_criteria":"- Unit tests cover classification, selection, transfer pipeline invariants.\n- Integration tests exercise hook â†” daemon socket and remote pipeline via mocks.\n- E2E scripts provide deterministic, logged runs (real and mock SSH).","notes":"Test tasks depend on core implementation tasks to avoid chasing moving targets.","status":"closed","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:18.360432736-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T10:41:59.626013603-05:00","closed_at":"2026-01-16T10:41:59.626013603-05:00","close_reason":"All child tasks completed: test infra, e2e script, integration tests","dependencies":[{"issue_id":"remote_compilation_helper-ei5.4","depends_on_id":"remote_compilation_helper-ei5","type":"parent-child","created_at":"2026-01-16T09:13:18.363214773-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.4.1","title":"Test infra: mock SSH/rsync transport","description":"Background\n- End-to-end tests need a deterministic environment; real SSH is flaky.\n\nGoals\n- Build a mock SSH/rsync layer (env var gated) for tests.\n- Provide detailed logs of each phase (sync, exec, artifacts).","design":"Use environment flags (e.g., RCH_MOCK_SSH=1) to swap transport implementation.","acceptance_criteria":"- Mock layer can simulate success/failure and captures command invocations.\n- Logs include timestamps and phase markers.","notes":"Keep mock behavior simple but explicit; avoid hidden side effects.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:19.097230314-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T10:15:05.617255074-05:00","closed_at":"2026-01-16T10:15:05.617255074-05:00","close_reason":"Closed","dependencies":[{"issue_id":"remote_compilation_helper-ei5.4.1","depends_on_id":"remote_compilation_helper-ei5.4","type":"parent-child","created_at":"2026-01-16T09:13:19.098448057-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.4.1","depends_on_id":"remote_compilation_helper-ei5.1.1","type":"blocks","created_at":"2026-01-16T09:13:19.57061581-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.4.2","title":"E2E: full pipeline script with detailed logging","description":"Background\n- Need reliable end-to-end validation for hook â†’ daemon â†’ worker flow.\n\nGoals\n- Provide scripts: real-worker and mock-SSH runs.\n- Capture logs, timings, and phase outcomes.\n- Validate artifacts exist locally after remote compile.","design":"Keep scripts idempotent and safe; avoid destructive actions.","acceptance_criteria":"- `scripts/e2e_test.sh` supports real and mock modes with clear output.\n- Failure modes (worker down, transfer fail) are exercised.","notes":"Integrate with `RCH_MOCK_SSH=1` to keep CI fast.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:19.16254388-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:16:53.752175219-05:00","closed_at":"2026-01-16T11:16:53.752175219-05:00","close_reason":"Closed","dependencies":[{"issue_id":"remote_compilation_helper-ei5.4.2","depends_on_id":"remote_compilation_helper-ei5.4","type":"parent-child","created_at":"2026-01-16T09:13:19.163650823-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.4.2","depends_on_id":"remote_compilation_helper-ei5.4.1","type":"blocks","created_at":"2026-01-16T09:13:19.6535995-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.4.2","depends_on_id":"remote_compilation_helper-ei5.1.1","type":"blocks","created_at":"2026-01-16T09:13:19.692475095-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.4.2","depends_on_id":"remote_compilation_helper-ei5.3.1","type":"blocks","created_at":"2026-01-16T09:13:19.731321424-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ei5.4.3","title":"Integration tests: hook/daemon/transfer sequencing","description":"Background\n- Integration tests ensure components interoperate across crate boundaries.\n\nGoals\n- Tests for daemon socket API parsing and responses.\n- Tests for selection + health interplay.\n- Tests for transfer pipeline sequencing (mocked).","design":"Reuse mock transport from test infra task; avoid duplication.","acceptance_criteria":"- Integration tests run via `cargo test` without needing real SSH.\n- Tests cover fail-open behavior and error propagation.","notes":"Ensure integration tests are deterministic and fast.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T09:13:19.238461577-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T10:15:08.669424347-05:00","closed_at":"2026-01-16T10:15:08.669424347-05:00","close_reason":"Closed","dependencies":[{"issue_id":"remote_compilation_helper-ei5.4.3","depends_on_id":"remote_compilation_helper-ei5.4","type":"parent-child","created_at":"2026-01-16T09:13:19.239940291-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-ei5.4.3","depends_on_id":"remote_compilation_helper-ei5.4.1","type":"blocks","created_at":"2026-01-16T09:13:19.614753431-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-eyd","title":"Implement worker health monitoring with heartbeats","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:46:13.579124926-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T08:52:05.008292273-05:00","closed_at":"2026-01-16T08:52:05.008292273-05:00","close_reason":"Implemented health.rs with HealthConfig, HealthCheckResult, WorkerHealth state tracking, and HealthMonitor background task. Monitors workers via SSH echo command, tracks consecutive failures, updates status to Healthy/Degraded/Unreachable. All 19 rchd tests pass."}
{"id":"remote_compilation_helper-gga","title":"Create installation script for local setup","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:46:14.901535898-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T08:57:20.522726579-05:00","closed_at":"2026-01-16T08:57:20.522726579-05:00","close_reason":"Installation script is complete and fully functional"}
{"id":"remote_compilation_helper-mrg","title":"Handle no-worker response in hook with graceful local fallback","description":"## Parent Epic: Graceful Local Fallback (remote_compilation_helper-ne8)\n\n## Task Description\n\nModify the hook logic to gracefully handle the case when the daemon returns no available worker. Instead of failing or blocking, the hook should allow local execution and log an informative message.\n\n## Current State\n\nLooking at rch/src/hook.rs, when the daemon returns a response, the hook processes it. Need to verify the current behavior when `worker` is `None` and ensure it falls back gracefully.\n\n## Changes Required\n\n### 1. Update Hook Response Handling\n```rust\n// In rch/src/hook.rs or similar\n\nasync fn handle_compilation_command(...) -\u003e HookDecision {\n    // Query daemon for worker\n    let response = query_daemon(\u0026socket, \u0026request).await?;\n    \n    // NEW: Handle no-worker case gracefully\n    match response.worker {\n        Some(worker) =\u003e {\n            // Proceed with remote compilation\n            execute_remotely(worker, command).await\n        }\n        None =\u003e {\n            // Log informative message based on reason\n            let reason_msg = match response.reason {\n                Some(SelectionReason::NoWorkersConfigured) =\u003e \n                    \"no workers configured\",\n                Some(SelectionReason::AllWorkersUnreachable) =\u003e \n                    \"all workers unreachable\",\n                Some(SelectionReason::AllWorkersBusy) =\u003e \n                    \"all workers at capacity\",\n                Some(SelectionReason::AllCircuitsOpen) =\u003e \n                    \"all worker circuits open (recovering)\",\n                _ =\u003e \"unknown reason\",\n            };\n            \n            // Log warning to stderr (visible to user)\n            eprintln!(\n                \"âš ï¸  RCH: No remote workers available ({}), executing locally\",\n                reason_msg\n            );\n            \n            // Return allow decision - local execution proceeds\n            HookDecision::Allow\n        }\n    }\n}\n```\n\n### 2. Ensure Consistent Fail-Open\n\nReview ALL error paths in hook.rs to ensure they return `Allow`:\n- Config load failure â†’ Allow\n- Socket connection failure â†’ Allow  \n- Daemon timeout â†’ Allow\n- Invalid response â†’ Allow\n- No worker available â†’ Allow (this task)\n\n### 3. Add Telemetry/Logging\n\nTrack fallback events for operational visibility:\n```rust\n// Log at INFO level so it appears in logs\ntracing::info!(\n    reason = %reason_msg,\n    project = %project_id,\n    \"Local fallback triggered\"\n);\n```\n\n## Files to Modify\n- `rch/src/hook.rs`\n- Possibly `rch/src/main.rs` if decision handling is there\n\n## Testing\n\n```rust\n#[tokio::test]\nasync fn test_hook_no_worker_fallback() {\n    // Setup mock daemon that returns no worker\n    let mock_response = SelectionResponse {\n        worker: None,\n        slots_reserved: 0,\n        reason: Some(SelectionReason::AllWorkersUnreachable),\n    };\n    \n    // Verify hook returns Allow\n    let decision = handle_compilation_with_mock(mock_response).await;\n    assert_eq!(decision, HookDecision::Allow);\n}\n\n#[tokio::test]\nasync fn test_hook_all_busy_fallback() {\n    // All workers busy\n    let mock_response = SelectionResponse {\n        worker: None,\n        slots_reserved: 0,\n        reason: Some(SelectionReason::AllWorkersBusy),\n    };\n    \n    let decision = handle_compilation_with_mock(mock_response).await;\n    assert_eq!(decision, HookDecision::Allow);\n}\n```\n\n## Acceptance Criteria\n- [ ] Hook returns Allow when no worker available\n- [ ] Informative message printed to stderr\n- [ ] Different messages for different reasons\n- [ ] INFO-level log entry for tracking\n- [ ] All error paths in hook return Allow (fail-open audit)\n- [ ] Tests cover all no-worker scenarios\n\n## Dependencies\n- Requires: \"Add reason field to SelectionResponse\" task\n\n## Estimated Effort: 2-3 hours","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:08:17.52218289-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:08:17.52218289-05:00","dependencies":[{"issue_id":"remote_compilation_helper-mrg","depends_on_id":"remote_compilation_helper-4ur","type":"blocks","created_at":"2026-01-16T12:08:42.770174732-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-nbo","title":"Add terminal colors and visual polish to CLI output","description":"## Overview\nTransform plain monochrome CLI output into polished, colored terminal output. Builds on the UI output abstraction layer.\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-u0v (UI output abstraction layer)\n\n## Requirements\n\n### Color Scheme\nUsing `colored` crate with consistent palette:\n- **Success**: Green (bright) - for âœ“, \"OK\", successful operations\n- **Error**: Red (bright) - for âœ—, errors, failures\n- **Warning**: Yellow - for âš , degraded states, non-critical issues\n- **Info**: Cyan - for informational messages, hints\n- **Header**: White/Bold - for section titles\n- **Muted**: Gray/Dim - for secondary information, timestamps\n- **Emphasis**: Bold - for important values, worker names\n\n### Visual Elements\n1. **Section Headers**: \n   ```\n   â•â•â• Worker Status â•â•â•\n   ```\n   Using box-drawing characters for premium feel\n\n2. **Key-Value Alignment**:\n   ```\n   Status:     Running\n   Socket:     /tmp/rch.sock\n   Uptime:     2h 15m\n   ```\n   Right-align labels, consistent spacing\n\n3. **Tables** (for workers list, status):\n   ```\n   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n   â”‚ Worker     â”‚ Host            â”‚ Status â”‚ Slots    â”‚\n   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n   â”‚ gpu-1      â”‚ gpu1.internal   â”‚ âœ“      â”‚ 32/64    â”‚\n   â”‚ cpu-fleet  â”‚ cpu.internal    â”‚ âš       â”‚ 8/16     â”‚\n   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n   ```\n   Consider `comfy-table` or `tabled` crate\n\n### Commands to Update\n- `rch status` - colorize all status indicators\n- `rch workers list` - table format with colors\n- `rch workers probe` - colored success/failure per worker\n- `rch workers benchmark` - colored results\n- `rch config show` - syntax-highlighted TOML-like output\n- `rch config validate` - colored checkmarks/warnings\n- `rch daemon status` - colored running/stopped indicator\n- `rch hook test` - colored test results\n\n## Testing Requirements\n\n### Unit Tests\n- Verify color codes are present in Human mode output\n- Verify NO color codes in Plain mode output\n- Verify table formatting is correct\n- Test each color function produces expected ANSI codes\n\n### Integration Tests\n- Snapshot tests comparing output format\n- Test color output disabled when piped\n\n### E2E Test Additions (scripts/e2e_test.sh)\n```bash\n# Scenario: colored output\nrun_scenario \"colored_output\" \"verify\" \"\"\n# Check that Human mode output contains ANSI codes\n# Check that piped output contains no ANSI codes\n```\n\n## Acceptance Criteria\n- [ ] All commands produce colored output in Human mode\n- [ ] Consistent color scheme across all commands\n- [ ] Tables render correctly with box-drawing characters\n- [ ] Key-value pairs are properly aligned\n- [ ] All unit tests pass\n- [ ] Visual inspection confirms premium appearance","status":"open","priority":1,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:36:30.753664152-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T11:56:46.120283933-05:00","dependencies":[{"issue_id":"remote_compilation_helper-nbo","depends_on_id":"remote_compilation_helper-u0v","type":"blocks","created_at":"2026-01-16T11:57:31.272148274-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ne8","title":"Epic: Graceful Local Fallback When No Workers Available","description":"## Overview\n\nImplement automatic local fallback when no healthy workers are available, completing RCH's fail-open philosophy. This is the second-highest impact improvement identified and addresses a critical gap in reliability.\n\n## Problem Statement\n\nCurrently, when the daemon has no healthy workers to assign (all unreachable, overloaded, or draining), the behavior may not gracefully degrade. The hook should NEVER prevent a build from happening - if remote compilation isn't possible, local compilation must proceed.\n\n## Goals\n\n1. When daemon returns no available worker, hook allows local execution\n2. User sees informative message explaining the fallback\n3. Telemetry tracks fallback events for monitoring\n4. System maintains fail-open semantics in ALL failure scenarios\n\n## Design\n\n### Protocol Changes\n- Add `reason: Option\u003cString\u003e` to SelectionResponse for no-worker cases\n- Possible reasons: \"all_workers_unreachable\", \"all_workers_busy\", \"no_workers_configured\"\n\n### Hook Behavior\n```\n1. Hook queries daemon for worker\n2. If daemon returns worker=null:\n   - Log warning: \"âš ï¸ RCH: No remote workers available ({reason}), executing locally\"\n   - Return \"allow\" decision to Claude Code\n3. Compilation proceeds locally\n```\n\n### Rationale\n\nThis is ranked #2 of 5 improvements because:\n- Completes the fail-open philosophy that is core to RCH\n- Ensures AI agents can ALWAYS compile (the entire point of RCH)\n- Builds user trust - system is transparent about degraded state\n- Minimal implementation effort with maximum reliability impact\n- Essential for production use - any worker outage would otherwise break workflows\n\n## Success Criteria\n\n- [ ] No scenario exists where RCH prevents a build from happening\n- [ ] User always sees clear messaging when fallback occurs\n- [ ] Fallback events are logged for operational visibility\n- [ ] All existing tests pass\n- [ ] New tests cover all fallback scenarios\n\n## Estimated Effort: 1-2 days\n\n## Dependencies: None (this is foundational)\n\n## Blocked By: Nothing - this should be implemented first","status":"open","priority":1,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:04:44.686384473-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:04:44.686384473-05:00"}
{"id":"remote_compilation_helper-od4","title":"Add comprehensive tests for local fallback scenarios","description":"## Parent Epic: Graceful Local Fallback (remote_compilation_helper-ne8)\n\n## Task Description\n\nCreate comprehensive test coverage for all local fallback scenarios. These tests ensure the fail-open philosophy is maintained across all edge cases.\n\n## Test Scenarios\n\n### 1. No Workers Configured\n```rust\n#[tokio::test]\nasync fn test_fallback_no_workers_configured() {\n    // Empty workers.toml\n    // Hook should: allow local, log \"no workers configured\"\n}\n```\n\n### 2. All Workers Unreachable\n```rust\n#[tokio::test]\nasync fn test_fallback_all_workers_unreachable() {\n    // All workers have status: Unreachable\n    // Hook should: allow local, log \"all workers unreachable\"\n}\n```\n\n### 3. All Workers Busy\n```rust\n#[tokio::test]\nasync fn test_fallback_all_workers_busy() {\n    // All workers at max slot capacity\n    // Hook should: allow local, log \"all workers at capacity\"\n}\n```\n\n### 4. Daemon Socket Missing\n```rust\n#[tokio::test]\nasync fn test_fallback_daemon_not_running() {\n    // Socket file doesn't exist\n    // Hook should: allow local, log \"daemon not running\"\n}\n```\n\n### 5. Daemon Timeout\n```rust\n#[tokio::test]\nasync fn test_fallback_daemon_timeout() {\n    // Daemon takes too long to respond\n    // Hook should: allow local after timeout, log \"daemon timeout\"\n}\n```\n\n### 6. Daemon Returns Error\n```rust\n#[tokio::test]\nasync fn test_fallback_daemon_error() {\n    // Daemon returns HTTP 500 or malformed response\n    // Hook should: allow local, log \"daemon error\"\n}\n```\n\n### 7. Mixed Worker States\n```rust\n#[tokio::test]\nasync fn test_fallback_mixed_states() {\n    // Some unreachable, some draining, some disabled\n    // None actually available\n    // Hook should: allow local with appropriate reason\n}\n```\n\n### 8. Network Partition During Selection\n```rust\n#[tokio::test]\nasync fn test_fallback_network_error() {\n    // Connection reset during daemon query\n    // Hook should: allow local, log \"connection error\"\n}\n```\n\n### 9. Repeated Fallbacks (Rate Limiting Check)\n```rust\n#[tokio::test]\nasync fn test_repeated_fallbacks_logged_appropriately() {\n    // Multiple fallbacks in short succession\n    // Verify logging doesn't spam excessively\n}\n```\n\n## Integration Tests\n\nAdd to e2e_test.sh:\n```bash\nrun_scenario \"no_workers\" \"allow\" \"no-workers\"\nrun_scenario \"all_unreachable\" \"allow\" \"all-unreachable\"\nrun_scenario \"daemon_down\" \"allow\" \"daemon-down\"\n```\n\n## Mock Infrastructure\n\nExtend MockConfig to support these scenarios:\n```rust\nimpl MockConfig {\n    pub fn no_workers() -\u003e Self { /* ... */ }\n    pub fn all_unreachable() -\u003e Self { /* ... */ }\n    pub fn all_busy() -\u003e Self { /* ... */ }\n    pub fn daemon_error() -\u003e Self { /* ... */ }\n}\n```\n\n## Files to Modify\n- `rch/src/hook.rs` (add test module)\n- `rch-common/src/mock.rs` (extend mock configs)\n- `scripts/e2e_test.sh` (add scenarios)\n\n## Acceptance Criteria\n- [ ] All 9 unit test scenarios implemented and passing\n- [ ] E2E test scenarios added and passing\n- [ ] Mock infrastructure extended for fallback testing\n- [ ] No scenario results in blocking/denial when it should fallback\n- [ ] Test names clearly describe the scenario\n\n## Dependencies\n- Requires: Both previous tasks in this epic\n\n## Estimated Effort: 2-3 hours","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:08:35.609332325-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:08:35.609332325-05:00","dependencies":[{"issue_id":"remote_compilation_helper-od4","depends_on_id":"remote_compilation_helper-mrg","type":"blocks","created_at":"2026-01-16T12:08:42.834306854-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-ova","title":"Integrate circuit breaker with worker selection","description":"## Parent Epic: Circuit Breaker Pattern (remote_compilation_helper-9pw)\n\n## Task Description\n\nModify the worker selection algorithm to exclude workers with open circuits. Workers in HalfOpen state should also be excluded from normal selection (they're only used for probing).\n\n## Current State\n\nIn `rchd/src/selection.rs`:\n```rust\npub async fn select_worker(\n    pool: \u0026WorkerPool,\n    request: \u0026SelectionRequest,\n    weights: \u0026SelectionWeights,\n) -\u003e Option\u003cArc\u003cWorkerState\u003e\u003e {\n    let healthy = pool.healthy_workers().await;\n    // ... scoring and selection\n}\n```\n\nThe current implementation filters by WorkerStatus (Healthy, Degraded) but doesn't consider circuit state.\n\n## Changes Required\n\n### 1. Add Circuit State Access\n\nNeed a way for selection to query circuit state. Options:\n- Store circuit state in WorkerState (simplest)\n- Pass HealthMonitor reference to selection (coupling)\n- Create shared circuit state registry (cleaner)\n\nRecommended: Store circuit state in WorkerState for simplicity.\n\n```rust\n// In workers.rs\npub struct WorkerState {\n    pub config: WorkerConfig,\n    status: RwLock\u003cWorkerStatus\u003e,\n    used_slots: AtomicU32,\n    pub speed_score: f64,\n    pub cached_projects: Vec\u003cString\u003e,\n    circuit_state: RwLock\u003cCircuitState\u003e,  // NEW\n}\n\nimpl WorkerState {\n    pub async fn circuit_state(\u0026self) -\u003e CircuitState {\n        self.circuit_state.read().await.clone()\n    }\n    \n    pub async fn set_circuit_state(\u0026self, state: CircuitState) {\n        *self.circuit_state.write().await = state;\n    }\n    \n    /// Check if worker is available for selection (healthy + circuit closed)\n    pub async fn is_available(\u0026self) -\u003e bool {\n        let status = self.status().await;\n        let circuit = self.circuit_state().await;\n        \n        matches!(status, WorkerStatus::Healthy | WorkerStatus::Degraded)\n            \u0026\u0026 circuit.is_closed()\n    }\n}\n```\n\n### 2. Update Selection Logic\n```rust\npub async fn select_worker(\n    pool: \u0026WorkerPool,\n    request: \u0026SelectionRequest,\n    weights: \u0026SelectionWeights,\n) -\u003e SelectionResponse {\n    // Get all workers\n    let all_workers = pool.all_workers().await;\n    \n    if all_workers.is_empty() {\n        return SelectionResponse::no_worker(SelectionReason::NoWorkersConfigured);\n    }\n    \n    // Filter to available workers (healthy/degraded + circuit closed)\n    let mut available = Vec::new();\n    let mut all_circuits_open = true;\n    let mut all_unreachable = true;\n    \n    for worker in all_workers {\n        let status = worker.status().await;\n        let circuit = worker.circuit_state().await;\n        \n        if !matches!(status, WorkerStatus::Unreachable | WorkerStatus::Disabled) {\n            all_unreachable = false;\n        }\n        \n        if circuit.is_closed() {\n            all_circuits_open = false;\n            if matches!(status, WorkerStatus::Healthy | WorkerStatus::Degraded) {\n                available.push(worker);\n            }\n        }\n    }\n    \n    if available.is_empty() {\n        let reason = if all_unreachable {\n            SelectionReason::AllWorkersUnreachable\n        } else if all_circuits_open {\n            SelectionReason::AllCircuitsOpen\n        } else {\n            SelectionReason::AllWorkersBusy\n        };\n        return SelectionResponse::no_worker(reason);\n    }\n    \n    // Filter by slot availability\n    let with_slots: Vec\u003c_\u003e = available\n        .into_iter()\n        .filter(|w| w.available_slots() \u003e= request.required_cores)\n        .collect();\n    \n    if with_slots.is_empty() {\n        return SelectionResponse::no_worker(SelectionReason::AllWorkersBusy);\n    }\n    \n    // Score and select best worker\n    let scored: Vec\u003c_\u003e = with_slots\n        .into_iter()\n        .map(|w| {\n            let score = calculate_score(\u0026w, request, weights);\n            (w, score)\n        })\n        .collect();\n    \n    let best = scored\n        .into_iter()\n        .max_by(|a, b| a.1.partial_cmp(\u0026b.1).unwrap())\n        .map(|(w, _)| w);\n    \n    // ... rest of selection\n}\n```\n\n### 3. Update Health Monitor to Sync Circuit State\n```rust\n// After updating health state, sync to worker state\npool.set_circuit_state(\u0026worker.config.id, health.circuit_state().clone()).await;\n```\n\n## Files to Modify\n- `rchd/src/workers.rs` - add circuit state to WorkerState\n- `rchd/src/selection.rs` - filter by circuit state\n- `rchd/src/health.rs` - sync circuit state to worker pool\n\n## Testing\n```rust\n#[tokio::test]\nasync fn test_selection_excludes_open_circuits() {\n    let pool = WorkerPool::new();\n    \n    // Add two workers\n    pool.add_worker(worker_config(\"w1\")).await;\n    pool.add_worker(worker_config(\"w2\")).await;\n    \n    // Open circuit on w1\n    pool.set_circuit_state(\n        \u0026WorkerId::new(\"w1\"),\n        CircuitState::Open {\n            tripped_at: Instant::now(),\n            trip_count: 1,\n            next_probe_at: Instant::now() + Duration::from_secs(60),\n        }\n    ).await;\n    \n    // Selection should only return w2\n    let request = SelectionRequest::default();\n    let response = select_worker(\u0026pool, \u0026request, \u0026SelectionWeights::default()).await;\n    \n    assert!(response.worker.is_some());\n    assert_eq!(response.worker.unwrap().id.as_str(), \"w2\");\n}\n\n#[tokio::test]\nasync fn test_selection_all_circuits_open() {\n    let pool = WorkerPool::new();\n    pool.add_worker(worker_config(\"w1\")).await;\n    \n    // Open circuit\n    pool.set_circuit_state(\u0026WorkerId::new(\"w1\"), CircuitState::Open { /* ... */ }).await;\n    \n    let response = select_worker(\u0026pool, \u0026request, \u0026weights).await;\n    \n    assert!(response.worker.is_none());\n    assert_eq!(response.reason, Some(SelectionReason::AllCircuitsOpen));\n}\n```\n\n## Acceptance Criteria\n- [ ] WorkerState includes circuit_state field\n- [ ] Selection filters out workers with open circuits\n- [ ] Selection filters out workers in half-open state\n- [ ] AllCircuitsOpen reason returned when appropriate\n- [ ] Circuit state synced from health monitor to worker pool\n- [ ] Tests cover circuit exclusion scenarios\n\n## Dependencies\n- Requires: \"Integrate circuit state into WorkerHealth\" task\n\n## Estimated Effort: 2-3 hours","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T12:11:22.978619487-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:11:22.978619487-05:00","dependencies":[{"issue_id":"remote_compilation_helper-ova","depends_on_id":"remote_compilation_helper-52l","type":"blocks","created_at":"2026-01-16T12:12:01.93377572-05:00","created_by":"Dicklesworthstone"}]}
{"id":"remote_compilation_helper-qq0","title":"Fix WorkerPool len() and set_status() methods","status":"closed","priority":2,"issue_type":"bug","owner":"jeff141421@gmail.com","created_at":"2026-01-16T08:58:32.833184859-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T09:07:01.026383152-05:00","closed_at":"2026-01-16T09:07:01.026383152-05:00","close_reason":"Fixed in commit 4321639 - added RwLock for status, AtomicUsize for len(), all_workers() method"}
{"id":"remote_compilation_helper-rwu","title":"Implement rsync transfer pipeline","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:20:07.608638498-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:30:30.514732797-05:00","closed_at":"2026-01-16T03:30:30.514732797-05:00","close_reason":"rsync transfer pipeline already implemented by PearlDune: sync_to_remote, execute_remote, retrieve_artifacts, cleanup_remote - all with zstd compression support. 4 tests pass."}
{"id":"remote_compilation_helper-sv9","title":"Implement rch-common shared library","description":"Create shared library with types.rs, protocol.rs, patterns.rs. Include compilation keywords and command classification types.","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:09:01.59083799-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:19:15.955070768-05:00","closed_at":"2026-01-16T03:19:15.955070768-05:00","close_reason":"Implemented types.rs, protocol.rs, patterns.rs with 5-tier classification system. All tests pass."}
{"id":"remote_compilation_helper-t4e","title":"Implement rchd local daemon","description":"Create rchd binary with main.rs, workers.rs, selection.rs. Manage worker pool state and selection algorithm.","status":"closed","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:09:03.785104124-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:19:12.913921133-05:00","closed_at":"2026-01-16T03:19:12.913921133-05:00","close_reason":"Closed"}
{"id":"remote_compilation_helper-u0o","title":"Implement SSH execution for remote commands","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:20:05.887941709-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:30:46.750830312-05:00","closed_at":"2026-01-16T03:30:46.750830312-05:00","close_reason":"SSH execution implemented by PearlDune in rch-common/src/ssh.rs: SshClient, SshPool, CommandResult with connection pooling, health checks, and streaming support. 3 tests pass."}
{"id":"remote_compilation_helper-u0v","title":"Create UI output abstraction layer (foundation for all CLI improvements)","description":"## Overview\nCreate a foundational output abstraction that ALL other CLI improvements build upon. This ensures consistent behavior across colors, progress, JSON output, error display, and logging.\n\n**This is the critical foundation** - every other UI bead depends on getting this right.\n\n## Requirements\n\n### Core Abstraction\nCreate `rch/src/ui/mod.rs` module (directory structure for future expansion) with:\n\n```rust\npub mod context;    // OutputContext and mode detection\npub mod style;      // Color and formatting definitions\npub mod writer;     // Thread-safe output writers\npub mod test_utils; // Test helpers (pub for integration tests)\n```\n\n### OutputMode Enum\n```rust\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum OutputMode {\n    Human,  // Colored, unicode symbols, progress bars\n    Plain,  // No colors, ASCII fallback, no animations\n    Json,   // Machine-readable JSON to stdout\n    Quiet,  // Errors only, minimal output\n}\n```\n\n### OutputContext Struct\n```rust\npub struct OutputContext {\n    mode: OutputMode,\n    verbosity: Verbosity,      // Normal, Verbose, Quiet\n    terminal_width: Option\u003cu16\u003e,\n    supports_unicode: bool,\n    stdout: OutputWriter,      // Thread-safe\n    stderr: OutputWriter,      // Thread-safe\n}\n```\n\n### Mode Detection Logic (Priority Order)\n1. `--json` flag â†’ Json mode (also implies --quiet for non-JSON output)\n2. `--quiet` / `-q` flag â†’ Quiet mode\n3. `--no-color` flag â†’ Plain mode\n4. `--color=always` flag â†’ Human mode (force colors even if not TTY)\n5. `NO_COLOR` env var set (any value) â†’ Plain mode (https://no-color.org/)\n6. `CLICOLOR_FORCE` env var set â†’ Human mode (force colors)\n7. `TERM=dumb` â†’ Plain mode\n8. stdout is not a TTY (piped) â†’ Plain mode for stdout, Human for stderr if TTY\n9. Otherwise â†’ Human mode\n\n### Verbosity Levels (Orthogonal to Mode)\n```rust\npub enum Verbosity {\n    Quiet,   // -q: Only errors\n    Normal,  // Default: Standard output\n    Verbose, // -v: Additional debug info\n}\n```\n\n### Output Streams: stdout vs stderr\n**Critical distinction:**\n- `stdout`: Primary output (results, JSON data, tables)\n- `stderr`: Progress indicators, spinners, status messages, errors, warnings\n\nThis allows: `rch status --json | jq .` to work while progress shows on terminal.\n\n### Thread-Safe Output\n```rust\npub struct OutputWriter {\n    inner: Arc\u003cMutex\u003cBox\u003cdyn Write + Send\u003e\u003e\u003e,\n    is_tty: bool,\n}\n\nimpl OutputWriter {\n    pub fn write_line(\u0026self, line: \u0026str);\n    pub fn write_styled(\u0026self, styled: \u0026StyledString);\n}\n```\n\nFor multi-progress (parallel worker probes), use `indicatif::MultiProgress` which handles this internally.\n\n### Terminal Capabilities Detection\n```rust\npub struct TerminalCaps {\n    pub width: u16,           // For table/progress bar sizing\n    pub height: u16,          // For paging (future)\n    pub supports_color: bool, // True color / 256 / 16 / none\n    pub supports_unicode: bool, // Can render âœ“âœ—âš  or need ASCII fallback\n}\n```\n\n**Unicode detection heuristic:**\n- Check `LANG`/`LC_ALL` for UTF-8\n- Check terminal type\n- Default to ASCII on Windows cmd.exe (not Windows Terminal)\n\n**ASCII fallbacks:**\n| Unicode | ASCII |\n|---------|-------|\n| âœ“ | [OK] |\n| âœ— | [FAIL] |\n| âš  | [WARN] |\n| â— | [*] |\n| â—‹ | [ ] |\n| â— | [~] |\n\n### Output Methods on OutputContext\n```rust\nimpl OutputContext {\n    // Status messages (to stderr in Human/Plain, suppressed in Quiet)\n    pub fn success(\u0026self, msg: \u0026str);\n    pub fn error(\u0026self, msg: \u0026str);\n    pub fn warning(\u0026self, msg: \u0026str);\n    pub fn info(\u0026self, msg: \u0026str);\n    pub fn debug(\u0026self, msg: \u0026str); // Only if verbose\n\n    // Structured output (to stdout)\n    pub fn print(\u0026self, msg: \u0026str);           // Raw print\n    pub fn header(\u0026self, title: \u0026str);        // Section header\n    pub fn key_value(\u0026self, key: \u0026str, value: \u0026str); // Aligned K/V\n    pub fn table(\u0026self, headers: \u0026[\u0026str], rows: \u0026[Vec\u003cString\u003e]);\n\n    // JSON output (only in Json mode, to stdout)\n    pub fn json\u003cT: Serialize\u003e(\u0026self, value: \u0026T) -\u003e Result\u003c()\u003e;\n\n    // Mode queries\n    pub fn is_tty(\u0026self) -\u003e bool;\n    pub fn is_json(\u0026self) -\u003e bool;\n    pub fn terminal_width(\u0026self) -\u003e u16;\n}\n```\n\n### Integration with tracing/logging\n- `RUST_LOG` output goes to stderr\n- In Human mode: tracing output shown if RUST_LOG set\n- In Json mode: tracing output suppressed (or structured via tracing-subscriber JSON)\n- tracing should not interfere with progress indicators\n\n### Crate Dependencies\n```toml\n[dependencies]\ncolored = \"2\"           # Color output\nis-terminal = \"0.4\"     # TTY detection (successor to atty)\nterminal_size = \"0.3\"   # Terminal dimensions\nserde_json = \"1\"        # JSON serialization\nunicode-width = \"0.1\"   # For proper text alignment\n```\n\n### CLI Integration\nAdd to main Cli struct:\n```rust\n#[derive(Parser)]\nstruct Cli {\n    #[arg(long, global = true, value_name = \"WHEN\", default_value = \"auto\")]\n    #[arg(value_parser = [\"auto\", \"always\", \"never\"])]\n    color: String,\n\n    #[arg(long, global = true, help = \"Output in JSON format\")]\n    json: bool,\n\n    #[arg(short, long, global = true, help = \"Verbose output\")]\n    verbose: bool,\n\n    #[arg(short, long, global = true, help = \"Suppress non-error output\")]\n    quiet: bool,\n\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n```\n\n### Pattern for Command Functions\n```rust\npub async fn workers_list(ctx: \u0026OutputContext) -\u003e Result\u003c()\u003e {\n    let workers = load_workers()?;\n\n    if ctx.is_json() {\n        ctx.json(\u0026WorkersListJson { workers: \u0026workers })?;\n        return Ok(());\n    }\n\n    ctx.header(\"Configured Workers\");\n    // ... human-readable output\n}\n```\n\n## Testing Requirements\n\n### Test Utilities Module (`rch/src/ui/test_utils.rs`)\n```rust\n/// Capture output for testing\npub struct OutputCapture {\n    stdout: Arc\u003cMutex\u003cVec\u003cu8\u003e\u003e\u003e,\n    stderr: Arc\u003cMutex\u003cVec\u003cu8\u003e\u003e\u003e,\n}\n\nimpl OutputCapture {\n    pub fn new() -\u003e (Self, OutputContext);\n    pub fn stdout_string(\u0026self) -\u003e String;\n    pub fn stderr_string(\u0026self) -\u003e String;\n    pub fn stdout_without_ansi(\u0026self) -\u003e String; // Strip color codes\n}\n\n/// Assert helpers\npub fn assert_contains_no_ansi(s: \u0026str);\npub fn assert_valid_json(s: \u0026str) -\u003e serde_json::Value;\n```\n\n### Unit Tests (rch/src/ui/*.rs)\n1. **Mode detection tests:**\n   - Test each detection rule in priority order\n   - Test combinations (--json with --color)\n   - Test env var detection (NO_COLOR, CLICOLOR_FORCE, TERM)\n\n2. **Output method tests:**\n   - Each method produces correct output per mode\n   - Unicode vs ASCII fallback\n   - Alignment with various terminal widths\n\n3. **Thread safety tests:**\n   - Concurrent writes don't interleave incorrectly\n   - Progress + output work together\n\n### Integration Tests (`rch/tests/ui_integration.rs`)\n```rust\n#[test]\nfn test_no_color_env_disables_colors() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .env(\"NO_COLOR\", \"1\")\n        .arg(\"status\")\n        .output()\n        .unwrap();\n    assert_contains_no_ansi(\u0026String::from_utf8_lossy(\u0026output.stdout));\n}\n\n#[test]\nfn test_pipe_disables_colors() {\n    // Pipe to cat, verify no ANSI codes\n}\n\n#[test]\nfn test_json_output_valid() {\n    let output = Command::new(env!(\"CARGO_BIN_EXE_rch\"))\n        .args([\"--json\", \"status\"])\n        .output()\n        .unwrap();\n    let json: serde_json::Value = serde_json::from_slice(\u0026output.stdout).unwrap();\n    assert!(json.is_object());\n}\n```\n\n### E2E Test Additions (`scripts/e2e_test.sh`)\n```bash\n# === Output Mode Tests ===\n\ntest_output_modes() {\n    log \"INFO\" \"OUTPUT\" \"Testing output mode detection...\"\n\n    # Test NO_COLOR compliance\n    local output\n    output=$(NO_COLOR=1 \"$RCH\" status 2\u003e\u00261)\n    if echo \"$output\" | grep -q $'\\x1b\\['; then\n        log \"FAIL\" \"OUTPUT\" \"NO_COLOR=1 still produced ANSI codes\"\n        return 1\n    fi\n    log \"INFO\" \"OUTPUT\" \"NO_COLOR compliance OK\"\n\n    # Test --json produces valid JSON\n    output=$(\"$RCH\" --json status 2\u003e\u00261)\n    if ! echo \"$output\" | jq . \u003e /dev/null 2\u003e\u00261; then\n        log \"FAIL\" \"OUTPUT\" \"--json produced invalid JSON\"\n        return 1\n    fi\n    log \"INFO\" \"OUTPUT\" \"JSON output OK\"\n\n    # Test pipe detection (stdout not TTY)\n    output=$(\"$RCH\" status | cat)\n    if echo \"$output\" | grep -q $'\\x1b\\['; then\n        log \"FAIL\" \"OUTPUT\" \"Piped output contains ANSI codes\"\n        return 1\n    fi\n    log \"INFO\" \"OUTPUT\" \"Pipe detection OK\"\n\n    # Test --color=always forces colors even when piped\n    output=$(\"$RCH\" --color=always status | cat)\n    if ! echo \"$output\" | grep -q $'\\x1b\\['; then\n        log \"FAIL\" \"OUTPUT\" \"--color=always didn't force colors\"\n        return 1\n    fi\n    log \"INFO\" \"OUTPUT\" \"--color=always OK\"\n}\n```\n\n## Acceptance Criteria\n- [ ] `OutputContext` correctly detects mode in all 9 detection scenarios\n- [ ] All output methods work correctly in all 4 modes\n- [ ] Unicode detection with ASCII fallback works\n- [ ] Thread-safe output verified with concurrent test\n- [ ] NO_COLOR standard fully compliant\n- [ ] CLICOLOR_FORCE supported\n- [ ] stderr/stdout separation correct\n- [ ] --color and --json flags work globally on all commands\n- [ ] Test utilities usable by other beads' tests\n- [ ] Unit test coverage \u003e90% for ui module\n- [ ] Integration tests pass\n- [ ] E2E output mode tests pass\n- [ ] No performance regression (mode detection should be \u003c1ms)","status":"open","priority":1,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:55:58.445816787-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:06:43.096887107-05:00"}
{"id":"remote_compilation_helper-v7u","title":"Implement Unix socket API for hook-daemon communication","status":"closed","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-16T03:20:10.927804477-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T03:27:18.781854725-05:00","closed_at":"2026-01-16T03:27:18.781854725-05:00","close_reason":"Implemented Unix socket API: created api.rs for daemon socket server, updated main.rs, added daemon client to hook.rs. All 35 tests pass, clippy clean."}
{"id":"remote_compilation_helper-x8d","title":"Add 'rch doctor' diagnostic command","description":"## Overview\nAdd comprehensive diagnostic command that checks all aspects of RCH setup and provides actionable remediation for any issues found.\n\n## Dependencies\n- **BLOCKED BY**: remote_compilation_helper-nbo (colors) - uses colored output\n- **BLOCKED BY**: remote_compilation_helper-cmj (status indicators) - uses standard indicators\n\n## Requirements\n\n### Command Signature\n```\nrch doctor [OPTIONS]\n\nRun comprehensive system diagnostics.\n\nOPTIONS:\n    --fix        Attempt to automatically fix simple issues\n    --json       Output results in JSON format\n    -v, --verbose Show detailed check information\n```\n\n### Diagnostic Checks\n\n#### 1. Prerequisites\n- [ ] rsync installed and in PATH\n- [ ] ssh installed and in PATH\n- [ ] Rust toolchain installed (for remote compilation)\n\n#### 2. Configuration\n- [ ] Config directory exists (~/.config/rch)\n- [ ] config.toml is valid (if exists)\n- [ ] workers.toml exists and is valid\n- [ ] At least one worker configured\n- [ ] Worker config values are reasonable (slots \u003e 0, etc.)\n\n#### 3. SSH Configuration\n- [ ] Identity files exist for each worker\n- [ ] Identity file permissions are correct (600)\n- [ ] Known hosts file is accessible\n\n#### 4. Daemon Status\n- [ ] Daemon socket exists\n- [ ] Daemon responds to ping\n- [ ] Daemon uptime (has it crashed recently?)\n\n#### 5. Worker Connectivity\n- [ ] Each worker is reachable via SSH\n- [ ] SSH authentication succeeds\n- [ ] Remote rsync is available on workers\n\n#### 6. Hook Installation\n- [ ] Claude Code settings.json exists\n- [ ] Hook is configured in settings\n- [ ] Hook path points to valid rch binary\n\n### Output Format\n```\nRCH Doctor\nâ•â•â•â•â•â•â•â•â•â•\n\nPrerequisites\n  âœ“ rsync 3.2.7 found at /usr/bin/rsync\n  âœ“ ssh OpenSSH_9.0 found at /usr/bin/ssh\n  âœ“ rustc 1.75.0 found at /home/user/.cargo/bin/rustc\n\nConfiguration\n  âœ“ Config directory: ~/.config/rch\n  âœ“ config.toml: Valid\n  âœ“ workers.toml: Valid (2 workers)\n\nWorkers\n  âœ“ gpu-worker: Reachable (45ms)\n  âš  cpu-worker: Slow response (2340ms)\n    â””â”€ Consider checking network connectivity\n\nDaemon\n  âœ“ Socket: /tmp/rch.sock\n  âœ“ Status: Running (uptime: 2h 15m)\n\nHook\n  âœ“ Settings: ~/.claude/settings.json\n  âœ“ Hook: Installed and configured\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nSummary: 10 passed, 1 warning, 0 errors\n\nOverall status: Healthy with warnings\n```\n\n### Auto-Fix Capabilities (--fix)\nWhen --fix is specified, attempt to fix:\n- Create missing config directory\n- Fix identity file permissions (chmod 600)\n- Initialize default config if missing\n- Restart daemon if not responding\n\n### JSON Output\n```json\n{\n  \"checks\": [\n    {\n      \"category\": \"prerequisites\",\n      \"name\": \"rsync\",\n      \"status\": \"pass\",\n      \"details\": \"rsync 3.2.7 at /usr/bin/rsync\"\n    },\n    {\n      \"category\": \"workers\",\n      \"name\": \"cpu-worker\",\n      \"status\": \"warning\",\n      \"details\": \"Slow response: 2340ms\",\n      \"suggestion\": \"Check network connectivity\"\n    }\n  ],\n  \"summary\": {\n    \"passed\": 10,\n    \"warnings\": 1,\n    \"errors\": 0,\n    \"status\": \"healthy_with_warnings\"\n  }\n}\n```\n\n### Files to Modify\n- `rch/src/commands.rs` - add doctor command implementation\n- `rch/src/main.rs` - add Doctor subcommand\n\n## Testing Requirements\n\n### Unit Tests\n- Test each individual check function\n- Test --fix operations (with mocks)\n- Test JSON output format\n\n### Integration Tests\n- Test full doctor run with valid config\n- Test doctor with missing config (should report)\n- Test doctor with unreachable worker (should report)\n\n### E2E Test Additions\n```bash\n# Scenario: doctor_command\n\ntest_doctor() {\n    # Run doctor and verify it completes\n    local output\n    output=$(rch doctor 2\u003e\u00261)\n    local exit_code=$?\n    \n    # Should not crash\n    if [[ $exit_code -gt 1 ]]; then\n        log \"FAIL\" \"DOCTOR\" \"Doctor command crashed\"\n        return 1\n    fi\n    \n    # Should have summary\n    if ! echo \"$output\" | grep -q \"Summary:\"; then\n        log \"FAIL\" \"DOCTOR\" \"Missing summary in output\"\n        return 1\n    fi\n    \n    log \"INFO\" \"DOCTOR\" \"Doctor command OK\"\n}\n\ntest_doctor_json() {\n    local output\n    output=$(rch doctor --json 2\u003e\u00261)\n    \n    if ! echo \"$output\" | jq . \u003e /dev/null 2\u003e\u00261; then\n        log \"FAIL\" \"DOCTOR\" \"Invalid JSON output\"\n        return 1\n    fi\n    \n    log \"INFO\" \"DOCTOR\" \"Doctor JSON output valid\"\n}\n```\n\n### Manual Testing Checklist\n- [ ] Run doctor with everything working\n- [ ] Run doctor with daemon stopped\n- [ ] Run doctor with worker unreachable\n- [ ] Run doctor with missing config\n- [ ] Test --fix repairs permission issues\n- [ ] Test --json produces valid JSON\n\n## Acceptance Criteria\n- [ ] All diagnostic categories implemented\n- [ ] Clear, actionable output for issues\n- [ ] --fix handles common issues\n- [ ] --json produces valid, structured output\n- [ ] Integrates with color scheme\n- [ ] Unit tests for each check\n- [ ] E2E tests verify command works","status":"open","priority":3,"issue_type":"feature","owner":"jeff141421@gmail.com","created_at":"2026-01-16T11:37:16.226548289-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-16T12:01:20.42108459-05:00","dependencies":[{"issue_id":"remote_compilation_helper-x8d","depends_on_id":"remote_compilation_helper-nbo","type":"blocks","created_at":"2026-01-16T12:02:12.06551255-05:00","created_by":"Dicklesworthstone"},{"issue_id":"remote_compilation_helper-x8d","depends_on_id":"remote_compilation_helper-cmj","type":"blocks","created_at":"2026-01-16T12:02:12.178771436-05:00","created_by":"Dicklesworthstone"}]}
